import{registerComponent as ee}from"/1/bundle/esm/l/en-US/bi/0/module/mi/lwc%2Fv%2F8_12_7/s/sha256-A4k_e_1rs5Y4edfd78wU8iL0ESRybIXT4kbpYdnL__Y/bundle_lwc.js";import{load as we}from"/1/bundle/esm/l/en-US/bi/0/module/mi/lwr%2FesmLoader%2Fv%2F0_16_11/s/sha256-XZ3-fTIQeMpr-t515p72MK4vr6gSnXsH3O_YELtRaFw/bundle_lwr_esmLoader.js";var te=Object.defineProperty,Ee=e=>te(e,"__esModule",{value:!0}),be=(e,t)=>()=>(t||(t={exports:{}},e(t.exports,t)),t.exports),_e=(e,t)=>{for(var s in t)te(e,s,{get:t[s],enumerable:!0})},Te=be(e=>{Ee(e),_e(e,{FilesystemWeb:()=>r});function t(n){const i=n.split("/").filter(a=>a!=="."),o=[];return i.forEach(a=>{a===".."&&o.length>0&&o[o.length-1]!==".."?o.pop():o.push(a)}),o.join("/")}function s(n,i){n=t(n),i=t(i);const o=n.split("/"),a=i.split("/");return n!==i&&o.every((l,h)=>l===a[h])}var r=class extends M{constructor(){super(...arguments);this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async n=>{var i,o;const a=ne(n,n.webFetchExtra),l=await fetch(n.url,a);let h;if(!n.progress)h=await l.blob();else if(!(l==null?void 0:l.body))h=new Blob;else{const u=l.body.getReader();let d=0;const y=[],g=l.headers.get("content-type"),w=parseInt(l.headers.get("content-length")||"0",10);for(;;){const{done:b,value:E}=await u.read();if(b)break;y.push(E),d+=(E==null?void 0:E.length)||0;const S={url:n.url,bytes:d,contentLength:w};this.notifyListeners("progress",S)}const c=new Uint8Array(d);let p=0;for(const b of y)typeof b!="undefined"&&(c.set(b,p),p+=b.length);h=new Blob([c.buffer],{type:g||void 0})}return{path:(await this.writeFile({path:n.path,directory:(i=n.directory)!==null&&i!==void 0?i:void 0,recursive:(o=n.recursive)!==null&&o!==void 0?o:!1,data:h})).uri,blob:h}}}readFileInChunks(n,i){throw this.unavailable("Method not implemented.")}async initDb(){if(this._db!==void 0)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((n,i)=>{const o=indexedDB.open(this.DB_NAME,this.DB_VERSION);o.onupgradeneeded=r.doUpgrade,o.onsuccess=()=>{this._db=o.result,n(o.result)},o.onerror=()=>i(o.error),o.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(n){const o=n.target.result;switch(n.oldVersion){case 0:case 1:default:o.objectStoreNames.contains("FileStorage")&&o.deleteObjectStore("FileStorage"),o.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}}async dbRequest(n,i){const o=this._writeCmds.indexOf(n)!==-1?"readwrite":"readonly";return this.initDb().then(a=>new Promise((l,h)=>{const d=a.transaction(["FileStorage"],o).objectStore("FileStorage")[n](...i);d.onsuccess=()=>l(d.result),d.onerror=()=>h(d.error)}))}async dbIndexRequest(n,i,o){const a=this._writeCmds.indexOf(i)!==-1?"readwrite":"readonly";return this.initDb().then(l=>new Promise((h,f)=>{const g=l.transaction(["FileStorage"],a).objectStore("FileStorage").index(n)[i](...o);g.onsuccess=()=>h(g.result),g.onerror=()=>f(g.error)}))}getPath(n,i){const o=i!==void 0?i.replace(/^[/]+|[/]+$/g,""):"";let a="";return n!==void 0&&(a+="/"+n),i!==""&&(a+="/"+o),a}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(n){const i=this.getPath(n.directory,n.path),o=await this.dbRequest("get",[i]);if(o===void 0)throw Error("File does not exist.");return{data:o.content?o.content:""}}async writeFile(n){const i=this.getPath(n.directory,n.path);let o=n.data;const a=n.encoding,l=n.recursive,h=await this.dbRequest("get",[i]);if(h&&h.type==="directory")throw Error("The supplied path is a directory.");const f=i.substr(0,i.lastIndexOf("/"));if(await this.dbRequest("get",[f])===void 0){const g=f.indexOf("/",1);if(g!==-1){const w=f.substr(g);await this.mkdir({path:w,directory:n.directory,recursive:l})}}if(!a&&!(o instanceof Blob)&&(o=o.indexOf(",")>=0?o.split(",")[1]:o,!this.isBase64String(o)))throw Error("The supplied data is not valid base64 content.");const d=Date.now(),y={path:i,folder:f,type:"file",size:o instanceof Blob?o.size:o.length,ctime:d,mtime:d,content:o};return await this.dbRequest("put",[y]),{uri:y.path}}async appendFile(n){const i=this.getPath(n.directory,n.path);let o=n.data;const a=n.encoding,l=i.substr(0,i.lastIndexOf("/")),h=Date.now();let f=h;const u=await this.dbRequest("get",[i]);if(u&&u.type==="directory")throw Error("The supplied path is a directory.");if(await this.dbRequest("get",[l])===void 0){const g=l.indexOf("/",1);if(g!==-1){const w=l.substr(g);await this.mkdir({path:w,directory:n.directory,recursive:!0})}}if(!a&&!this.isBase64String(o))throw Error("The supplied data is not valid base64 content.");if(u!==void 0){if(u.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");u.content!==void 0&&!a?o=btoa(atob(u.content)+atob(o)):o=u.content+o,f=u.ctime}const y={path:i,folder:l,type:"file",size:o.length,ctime:f,mtime:h,content:o};await this.dbRequest("put",[y])}async deleteFile(n){const i=this.getPath(n.directory,n.path);if(await this.dbRequest("get",[i])===void 0)throw Error("File does not exist.");if((await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(i)])).length!==0)throw Error("Folder is not empty.");await this.dbRequest("delete",[i])}async mkdir(n){const i=this.getPath(n.directory,n.path),o=n.recursive,a=i.substr(0,i.lastIndexOf("/")),l=(i.match(/\//g)||[]).length,h=await this.dbRequest("get",[a]),f=await this.dbRequest("get",[i]);if(l===1)throw Error("Cannot create Root directory");if(f!==void 0)throw Error("Current directory does already exist.");if(!o&&l!==2&&h===void 0)throw Error("Parent directory must exist");if(o&&l!==2&&h===void 0){const y=a.substr(a.indexOf("/",1));await this.mkdir({path:y,directory:n.directory,recursive:o})}const u=Date.now(),d={path:i,folder:a,type:"directory",size:0,ctime:u,mtime:u};await this.dbRequest("put",[d])}async rmdir(n){const{path:i,directory:o,recursive:a}=n,l=this.getPath(o,i),h=await this.dbRequest("get",[l]);if(h===void 0)throw Error("Folder does not exist.");if(h.type!=="directory")throw Error("Requested path is not a directory");const f=await this.readdir({path:i,directory:o});if(f.files.length!==0&&!a)throw Error("Folder is not empty");for(const u of f.files){const d=`${i}/${u.name}`;(await this.stat({path:d,directory:o})).type==="file"?await this.deleteFile({path:d,directory:o}):await this.rmdir({path:d,directory:o,recursive:a})}await this.dbRequest("delete",[l])}async readdir(n){const i=this.getPath(n.directory,n.path),o=await this.dbRequest("get",[i]);if(n.path!==""&&o===void 0)throw Error("Folder does not exist.");const a=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(i)]);return{files:await Promise.all(a.map(async h=>{let f=await this.dbRequest("get",[h]);return f===void 0&&(f=await this.dbRequest("get",[h+"/"])),{name:h.substring(i.length+1),type:f.type,size:f.size,ctime:f.ctime,mtime:f.mtime,uri:f.path}}))}}async getUri(n){const i=this.getPath(n.directory,n.path);let o=await this.dbRequest("get",[i]);return o===void 0&&(o=await this.dbRequest("get",[i+"/"])),{uri:(o==null?void 0:o.path)||i}}async stat(n){const i=this.getPath(n.directory,n.path);let o=await this.dbRequest("get",[i]);if(o===void 0&&(o=await this.dbRequest("get",[i+"/"])),o===void 0)throw Error("Entry does not exist.");return{name:o.path.substring(i.length+1),type:o.type,size:o.size,ctime:o.ctime,mtime:o.mtime,uri:o.path}}async rename(n){await this._copy(n,!0)}async copy(n){return this._copy(n,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(n,i=!1){let{toDirectory:o}=n;const{to:a,from:l,directory:h}=n;if(!a||!l)throw Error("Both to and from must be provided");o||(o=h);const f=this.getPath(h,l),u=this.getPath(o,a);if(f===u)return{uri:u};if(s(f,u))throw Error("To path cannot contain the from path");let d;try{d=await this.stat({path:a,directory:o})}catch(c){const p=a.split("/");p.pop();const b=p.join("/");if(p.length>0&&(await this.stat({path:b,directory:o})).type!=="directory")throw new Error("Parent directory of the to path is a file")}if(d&&d.type==="directory")throw new Error("Cannot overwrite a directory with a file");const y=await this.stat({path:l,directory:h}),g=async(c,p,b)=>{const E=this.getPath(o,c),S=await this.dbRequest("get",[E]);S.ctime=p,S.mtime=b,await this.dbRequest("put",[S])},w=y.ctime?y.ctime:Date.now();switch(y.type){case"file":{const c=await this.readFile({path:l,directory:h});i&&await this.deleteFile({path:l,directory:h});let p;!(c.data instanceof Blob)&&!this.isBase64String(c.data)&&(p=B.UTF8);const b=await this.writeFile({path:a,directory:o,data:c.data,encoding:p});return i&&await g(a,w,y.mtime),b}case"directory":{if(d)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:a,directory:o,recursive:!1}),i&&await g(a,w,y.mtime)}catch(p){}const c=(await this.readdir({path:l,directory:h})).files;for(const p of c)await this._copy({from:`${l}/${p.name}`,to:`${a}/${p.name}`,directory:h,toDirectory:o},i);i&&await this.rmdir({path:l,directory:h})}}return{uri:u}}isBase64String(n){try{return btoa(atob(n))==n}catch(i){return!1}}};r._debug=!0});/*! Capacitor: https://capacitorjs.com/ - MIT License */var k;(function(e){e.Unimplemented="UNIMPLEMENTED",e.Unavailable="UNAVAILABLE"})(k||(k={}));var j=class extends Error{constructor(e,t,s){super(e);this.message=e,this.code=t,this.data=s}},Se=e=>{var t,s;return(e==null?void 0:e.androidBridge)?"android":((s=(t=e==null?void 0:e.webkit)===null||t===void 0?void 0:t.messageHandlers)===null||s===void 0?void 0:s.bridge)?"ios":"web"},ve=e=>{const t=e.CapacitorCustomPlatform||null,s=e.Capacitor||{},r=s.Plugins=s.Plugins||{},n=()=>t!==null?t.name:Se(e),i=()=>n()!=="web",o=u=>{const d=h.get(u);return!!((d==null?void 0:d.platforms.has(n()))||a(u))},a=u=>{var d;return(d=s.PluginHeaders)===null||d===void 0?void 0:d.find(y=>y.name===u)},l=u=>e.console.error(u),h=new Map,f=(u,d={})=>{const y=h.get(u);if(y)return console.warn(`Capacitor plugin "${u}" already registered. Cannot register plugins twice.`),y.proxy;const g=n(),w=a(u);let c;const p=async()=>(!c&&g in d?c=typeof d[g]=="function"?c=await d[g]():c=d[g]:t!==null&&!c&&"web"in d&&(c=typeof d.web=="function"?c=await d.web():c=d.web),c),b=(m,_)=>{var v,C;if(w){const I=w==null?void 0:w.methods.find(T=>_===T.name);if(I)return I.rtype==="promise"?T=>s.nativePromise(u,_.toString(),T):(T,L)=>s.nativeCallback(u,_.toString(),T,L);if(m)return(v=m[_])===null||v===void 0?void 0:v.bind(m)}else{if(m)return(C=m[_])===null||C===void 0?void 0:C.bind(m);throw new j(`"${u}" plugin is not implemented on ${g}`,k.Unimplemented)}},E=m=>{let _;const v=(...C)=>{const I=p().then(T=>{const L=b(T,m);if(L){const A=L(...C);return _=A==null?void 0:A.remove,A}else throw new j(`"${u}.${m}()" is not implemented on ${g}`,k.Unimplemented)});return m==="addListener"&&(I.remove=async()=>_()),I};return v.toString=()=>`${m.toString()}() { [capacitor code] }`,Object.defineProperty(v,"name",{value:m,writable:!1,configurable:!1}),v},S=E("addListener"),P=E("removeListener"),$=(m,_)=>{const v=S({eventName:m},_),C=async()=>{const T=await v;P({eventName:m,callbackId:T},_)},I=new Promise(T=>v.then(()=>T({remove:C})));return I.remove=async()=>{console.warn("Using addListener() without 'await' is deprecated."),await C()},I},N=new Proxy({},{get(m,_){switch(_){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return w?$:S;case"removeListener":return P;default:return E(_)}}});return r[u]=N,h.set(u,{name:u,proxy:N,platforms:new Set([...Object.keys(d),...w?[g]:[]])}),N};return s.convertFileSrc||(s.convertFileSrc=u=>u),s.getPlatform=n,s.handleError=l,s.isNativePlatform=i,s.isPluginAvailable=o,s.registerPlugin=f,s.Exception=j,s.DEBUG=!!s.DEBUG,s.isLoggingEnabled=!!s.isLoggingEnabled,s},Ce=e=>e.Capacitor=ve(e),q=Ce(typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:typeof globalThis!="undefined"?globalThis:{}),x=q.registerPlugin,M=class{constructor(){this.listeners={},this.retainedEventArguments={},this.windowListeners={}}addListener(e,t){let s=!1;this.listeners[e]||(this.listeners[e]=[],s=!0),this.listeners[e].push(t);const n=this.windowListeners[e];n&&!n.registered&&this.addWindowListener(n),s&&this.sendRetainedArgumentsForEvent(e);const i=async()=>this.removeListener(e,t);return Promise.resolve({remove:i})}async removeAllListeners(){this.listeners={};for(const e in this.windowListeners)this.removeWindowListener(this.windowListeners[e]);this.windowListeners={}}notifyListeners(e,t,s){const r=this.listeners[e];if(!r){if(s){let n=this.retainedEventArguments[e];n||(n=[]),n.push(t),this.retainedEventArguments[e]=n}return}r.forEach(n=>n(t))}hasListeners(e){var t;return!!((t=this.listeners[e])===null||t===void 0?void 0:t.length)}registerWindowListener(e,t){this.windowListeners[t]={registered:!1,windowEventName:e,pluginEventName:t,handler:s=>{this.notifyListeners(t,s)}}}unimplemented(e="not implemented"){return new q.Exception(e,k.Unimplemented)}unavailable(e="not available"){return new q.Exception(e,k.Unavailable)}async removeListener(e,t){const s=this.listeners[e];if(!s)return;const r=s.indexOf(t);this.listeners[e].splice(r,1),this.listeners[e].length||this.removeWindowListener(this.windowListeners[e])}addWindowListener(e){window.addEventListener(e.windowEventName,e.handler),e.registered=!0}removeWindowListener(e){!e||(window.removeEventListener(e.windowEventName,e.handler),e.registered=!1)}sendRetainedArgumentsForEvent(e){const t=this.retainedEventArguments[e];!t||(delete this.retainedEventArguments[e],t.forEach(s=>{this.notifyListeners(e,s)}))}},se=e=>encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape),re=e=>e.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent),Ie=class extends M{async getCookies(){const e=document.cookie,t={};return e.split(";").forEach(s=>{if(s.length<=0)return;let[r,n]=s.replace(/=/,"CAP_COOKIE").split("CAP_COOKIE");r=re(r).trim(),n=re(n).trim(),t[r]=n}),t}async setCookie(e){try{const t=se(e.key),s=se(e.value),r=`; expires=${(e.expires||"").replace("expires=","")}`,n=(e.path||"/").replace("path=",""),i=e.url!=null&&e.url.length>0?`domain=${e.url}`:"";document.cookie=`${t}=${s||""}${r}; path=${n}; ${i};`}catch(t){return Promise.reject(t)}}async deleteCookie(e){try{document.cookie=`${e.key}=; Max-Age=0`}catch(t){return Promise.reject(t)}}async clearCookies(){try{const e=document.cookie.split(";")||[];for(const t of e)document.cookie=t.replace(/^ +/,"").replace(/=.*/,`=;expires=${new Date().toUTCString()};path=/`)}catch(e){return Promise.reject(e)}}async clearAllCookies(){try{await this.clearCookies()}catch(e){return Promise.reject(e)}}};x("CapacitorCookies",{web:()=>new Ie});var Pe=async e=>new Promise((t,s)=>{const r=new FileReader;r.onload=()=>{const n=r.result;t(n.indexOf(",")>=0?n.split(",")[1]:n)},r.onerror=n=>s(n),r.readAsDataURL(e)}),Le=(e={})=>{const t=Object.keys(e);return Object.keys(e).map(n=>n.toLocaleLowerCase()).reduce((n,i,o)=>(n[i]=e[t[o]],n),{})},Ae=(e,t=!0)=>e?Object.entries(e).reduce((r,n)=>{const[i,o]=n;let a,l;return Array.isArray(o)?(l="",o.forEach(h=>{a=t?encodeURIComponent(h):h,l+=`${i}=${a}&`}),l.slice(0,-1)):(a=t?encodeURIComponent(o):o,l=`${i}=${a}`),`${r}&${l}`},"").substr(1):null,ne=(e,t={})=>{const s=Object.assign({method:e.method||"GET",headers:e.headers},t),n=Le(e.headers)["content-type"]||"";if(typeof e.data=="string")s.body=e.data;else if(n.includes("application/x-www-form-urlencoded")){const i=new URLSearchParams;for(const[o,a]of Object.entries(e.data||{}))i.set(o,a);s.body=i.toString()}else if(n.includes("multipart/form-data")||e.data instanceof FormData){const i=new FormData;if(e.data instanceof FormData)e.data.forEach((a,l)=>{i.append(l,a)});else for(const a of Object.keys(e.data))i.append(a,e.data[a]);s.body=i;const o=new Headers(s.headers);o.delete("content-type"),s.headers=o}else(n.includes("application/json")||typeof e.data=="object")&&(s.body=JSON.stringify(e.data));return s},Re=class extends M{async request(e){const t=ne(e,e.webFetchExtra),s=Ae(e.params,e.shouldEncodeUrlParams),r=s?`${e.url}?${s}`:e.url,n=await fetch(r,t),i=n.headers.get("content-type")||"";let{responseType:o="text"}=n.ok?e:{};i.includes("application/json")&&(o="json");let a,l;switch(o){case"arraybuffer":case"blob":l=await n.blob(),a=await Pe(l);break;case"json":a=await n.json();break;case"document":case"text":default:a=await n.text()}const h={};return n.headers.forEach((f,u)=>{h[u]=f}),{data:a,headers:h,status:n.status,url:n.url}}async get(e){return this.request(Object.assign(Object.assign({},e),{method:"GET"}))}async post(e){return this.request(Object.assign(Object.assign({},e),{method:"POST"}))}async put(e){return this.request(Object.assign(Object.assign({},e),{method:"PUT"}))}async patch(e){return this.request(Object.assign(Object.assign({},e),{method:"PATCH"}))}async delete(e){return this.request(Object.assign(Object.assign({},e),{method:"DELETE"}))}};x("CapacitorHttp",{web:()=>new Re});function Oe(e){e.CapacitorUtils.Synapse=new Proxy({},{get(t,s){return new Proxy({},{get(r,n){return(i,o,a)=>{const l=e.Capacitor.Plugins[s];if(l===void 0){a(new Error(`Capacitor plugin ${s} not found`));return}if(typeof l[n]!="function"){a(new Error(`Method ${n} not found in Capacitor plugin ${s}`));return}(async()=>{try{const h=await l[n](i);o(h)}catch(h){a(h)}})()}}})}})}function Ue(e){e.CapacitorUtils.Synapse=new Proxy({},{get(t,s){return e.cordova.plugins[s]}})}function Ne(e=!1){typeof window>"u"||(window.CapacitorUtils=window.CapacitorUtils||{},window.Capacitor!==void 0&&!e?Oe(window):window.cordova!==void 0&&Ue(window))}var oe;(function(e){e.Documents="DOCUMENTS",e.Data="DATA",e.Library="LIBRARY",e.Cache="CACHE",e.External="EXTERNAL",e.ExternalStorage="EXTERNAL_STORAGE",e.ExternalCache="EXTERNAL_CACHE",e.LibraryNoCloud="LIBRARY_NO_CLOUD",e.Temporary="TEMPORARY"})(oe||(oe={}));var B;(function(e){e.UTF8="utf8",e.ASCII="ascii",e.UTF16="utf16"})(B||(B={}));var ie=x("Filesystem",{web:()=>Promise.resolve().then(()=>Te()).then(e=>new e.FilesystemWeb)});Ne();var ae=Object.defineProperty,ke=e=>ae(e,"__esModule",{value:!0}),Fe=(e,t)=>()=>(t||(t={exports:{}},e(t.exports,t)),t.exports),De=(e,t)=>{for(var s in t)ae(e,s,{get:t[s],enumerable:!0})},$e=Fe(e=>{ke(e),De(e,{Network:()=>r,NetworkWeb:()=>s});function t(){const n=window.navigator.connection||window.navigator.mozConnection||window.navigator.webkitConnection;let i="unknown";const o=n?n.type||n.effectiveType:null;if(o&&typeof o=="string")switch(o){case"bluetooth":case"cellular":i="cellular";break;case"none":i="none";break;case"ethernet":case"wifi":case"wimax":i="wifi";break;case"other":case"unknown":i="unknown";break;case"slow-2g":case"2g":case"3g":i="cellular";break;case"4g":i="wifi";break}return i}var s=class extends V{constructor(){super();this.handleOnline=()=>{const n=t(),i={connected:!0,connectionType:n};this.notifyListeners("networkStatusChange",i)},this.handleOffline=()=>{const n={connected:!1,connectionType:"none"};this.notifyListeners("networkStatusChange",n)},typeof window!="undefined"&&(window.addEventListener("online",this.handleOnline),window.addEventListener("offline",this.handleOffline))}async getStatus(){if(!window.navigator)throw this.unavailable("Browser does not support the Network Information API");const n=window.navigator.onLine,i=t();return{connected:n,connectionType:n?i:"none"}}},r=new s});/*! Capacitor: https://capacitorjs.com/ - MIT License */var F;(function(e){e.Unimplemented="UNIMPLEMENTED",e.Unavailable="UNAVAILABLE"})(F||(F={}));var W=class extends Error{constructor(e,t,s){super(e);this.message=e,this.code=t,this.data=s}},je=e=>{var t,s;return(e==null?void 0:e.androidBridge)?"android":((s=(t=e==null?void 0:e.webkit)===null||t===void 0?void 0:t.messageHandlers)===null||s===void 0?void 0:s.bridge)?"ios":"web"},qe=e=>{const t=e.CapacitorCustomPlatform||null,s=e.Capacitor||{},r=s.Plugins=s.Plugins||{},n=()=>t!==null?t.name:je(e),i=()=>n()!=="web",o=u=>{const d=h.get(u);return!!((d==null?void 0:d.platforms.has(n()))||a(u))},a=u=>{var d;return(d=s.PluginHeaders)===null||d===void 0?void 0:d.find(y=>y.name===u)},l=u=>e.console.error(u),h=new Map,f=(u,d={})=>{const y=h.get(u);if(y)return console.warn(`Capacitor plugin "${u}" already registered. Cannot register plugins twice.`),y.proxy;const g=n(),w=a(u);let c;const p=async()=>(!c&&g in d?c=typeof d[g]=="function"?c=await d[g]():c=d[g]:t!==null&&!c&&"web"in d&&(c=typeof d.web=="function"?c=await d.web():c=d.web),c),b=(m,_)=>{var v,C;if(w){const I=w==null?void 0:w.methods.find(T=>_===T.name);if(I)return I.rtype==="promise"?T=>s.nativePromise(u,_.toString(),T):(T,L)=>s.nativeCallback(u,_.toString(),T,L);if(m)return(v=m[_])===null||v===void 0?void 0:v.bind(m)}else{if(m)return(C=m[_])===null||C===void 0?void 0:C.bind(m);throw new W(`"${u}" plugin is not implemented on ${g}`,F.Unimplemented)}},E=m=>{let _;const v=(...C)=>{const I=p().then(T=>{const L=b(T,m);if(L){const A=L(...C);return _=A==null?void 0:A.remove,A}else throw new W(`"${u}.${m}()" is not implemented on ${g}`,F.Unimplemented)});return m==="addListener"&&(I.remove=async()=>_()),I};return v.toString=()=>`${m.toString()}() { [capacitor code] }`,Object.defineProperty(v,"name",{value:m,writable:!1,configurable:!1}),v},S=E("addListener"),P=E("removeListener"),$=(m,_)=>{const v=S({eventName:m},_),C=async()=>{const T=await v;P({eventName:m,callbackId:T},_)},I=new Promise(T=>v.then(()=>T({remove:C})));return I.remove=async()=>{console.warn("Using addListener() without 'await' is deprecated."),await C()},I},N=new Proxy({},{get(m,_){switch(_){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return w?$:S;case"removeListener":return P;default:return E(_)}}});return r[u]=N,h.set(u,{name:u,proxy:N,platforms:new Set([...Object.keys(d),...w?[g]:[]])}),N};return s.convertFileSrc||(s.convertFileSrc=u=>u),s.getPlatform=n,s.handleError=l,s.isNativePlatform=i,s.isPluginAvailable=o,s.registerPlugin=f,s.Exception=W,s.DEBUG=!!s.DEBUG,s.isLoggingEnabled=!!s.isLoggingEnabled,s},xe=e=>e.Capacitor=qe(e),J=xe(typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:typeof globalThis!="undefined"?globalThis:{}),X=J.registerPlugin,V=class{constructor(){this.listeners={},this.retainedEventArguments={},this.windowListeners={}}addListener(e,t){let s=!1;this.listeners[e]||(this.listeners[e]=[],s=!0),this.listeners[e].push(t);const n=this.windowListeners[e];n&&!n.registered&&this.addWindowListener(n),s&&this.sendRetainedArgumentsForEvent(e);const i=async()=>this.removeListener(e,t);return Promise.resolve({remove:i})}async removeAllListeners(){this.listeners={};for(const e in this.windowListeners)this.removeWindowListener(this.windowListeners[e]);this.windowListeners={}}notifyListeners(e,t,s){const r=this.listeners[e];if(!r){if(s){let n=this.retainedEventArguments[e];n||(n=[]),n.push(t),this.retainedEventArguments[e]=n}return}r.forEach(n=>n(t))}hasListeners(e){var t;return!!((t=this.listeners[e])===null||t===void 0?void 0:t.length)}registerWindowListener(e,t){this.windowListeners[t]={registered:!1,windowEventName:e,pluginEventName:t,handler:s=>{this.notifyListeners(t,s)}}}unimplemented(e="not implemented"){return new J.Exception(e,F.Unimplemented)}unavailable(e="not available"){return new J.Exception(e,F.Unavailable)}async removeListener(e,t){const s=this.listeners[e];if(!s)return;const r=s.indexOf(t);this.listeners[e].splice(r,1),this.listeners[e].length||this.removeWindowListener(this.windowListeners[e])}addWindowListener(e){window.addEventListener(e.windowEventName,e.handler),e.registered=!0}removeWindowListener(e){!e||(window.removeEventListener(e.windowEventName,e.handler),e.registered=!1)}sendRetainedArgumentsForEvent(e){const t=this.retainedEventArguments[e];!t||(delete this.retainedEventArguments[e],t.forEach(s=>{this.notifyListeners(e,s)}))}},ce=e=>encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape),le=e=>e.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent),Me=class extends V{async getCookies(){const e=document.cookie,t={};return e.split(";").forEach(s=>{if(s.length<=0)return;let[r,n]=s.replace(/=/,"CAP_COOKIE").split("CAP_COOKIE");r=le(r).trim(),n=le(n).trim(),t[r]=n}),t}async setCookie(e){try{const t=ce(e.key),s=ce(e.value),r=`; expires=${(e.expires||"").replace("expires=","")}`,n=(e.path||"/").replace("path=",""),i=e.url!=null&&e.url.length>0?`domain=${e.url}`:"";document.cookie=`${t}=${s||""}${r}; path=${n}; ${i};`}catch(t){return Promise.reject(t)}}async deleteCookie(e){try{document.cookie=`${e.key}=; Max-Age=0`}catch(t){return Promise.reject(t)}}async clearCookies(){try{const e=document.cookie.split(";")||[];for(const t of e)document.cookie=t.replace(/^ +/,"").replace(/=.*/,`=;expires=${new Date().toUTCString()};path=/`)}catch(e){return Promise.reject(e)}}async clearAllCookies(){try{await this.clearCookies()}catch(e){return Promise.reject(e)}}};X("CapacitorCookies",{web:()=>new Me});var Be=async e=>new Promise((t,s)=>{const r=new FileReader;r.onload=()=>{const n=r.result;t(n.indexOf(",")>=0?n.split(",")[1]:n)},r.onerror=n=>s(n),r.readAsDataURL(e)}),We=(e={})=>{const t=Object.keys(e);return Object.keys(e).map(n=>n.toLocaleLowerCase()).reduce((n,i,o)=>(n[i]=e[t[o]],n),{})},Je=(e,t=!0)=>e?Object.entries(e).reduce((r,n)=>{const[i,o]=n;let a,l;return Array.isArray(o)?(l="",o.forEach(h=>{a=t?encodeURIComponent(h):h,l+=`${i}=${a}&`}),l.slice(0,-1)):(a=t?encodeURIComponent(o):o,l=`${i}=${a}`),`${r}&${l}`},"").substr(1):null,Xe=(e,t={})=>{const s=Object.assign({method:e.method||"GET",headers:e.headers},t),n=We(e.headers)["content-type"]||"";if(typeof e.data=="string")s.body=e.data;else if(n.includes("application/x-www-form-urlencoded")){const i=new URLSearchParams;for(const[o,a]of Object.entries(e.data||{}))i.set(o,a);s.body=i.toString()}else if(n.includes("multipart/form-data")||e.data instanceof FormData){const i=new FormData;if(e.data instanceof FormData)e.data.forEach((a,l)=>{i.append(l,a)});else for(const a of Object.keys(e.data))i.append(a,e.data[a]);s.body=i;const o=new Headers(s.headers);o.delete("content-type"),s.headers=o}else(n.includes("application/json")||typeof e.data=="object")&&(s.body=JSON.stringify(e.data));return s},Ve=class extends V{async request(e){const t=Xe(e,e.webFetchExtra),s=Je(e.params,e.shouldEncodeUrlParams),r=s?`${e.url}?${s}`:e.url,n=await fetch(r,t),i=n.headers.get("content-type")||"";let{responseType:o="text"}=n.ok?e:{};i.includes("application/json")&&(o="json");let a,l;switch(o){case"arraybuffer":case"blob":l=await n.blob(),a=await Be(l);break;case"json":a=await n.json();break;case"document":case"text":default:a=await n.text()}const h={};return n.headers.forEach((f,u)=>{h[u]=f}),{data:a,headers:h,status:n.status,url:n.url}}async get(e){return this.request(Object.assign(Object.assign({},e),{method:"GET"}))}async post(e){return this.request(Object.assign(Object.assign({},e),{method:"POST"}))}async put(e){return this.request(Object.assign(Object.assign({},e),{method:"PUT"}))}async patch(e){return this.request(Object.assign(Object.assign({},e),{method:"PATCH"}))}async delete(e){return this.request(Object.assign(Object.assign({},e),{method:"DELETE"}))}};X("CapacitorHttp",{web:()=>new Ve});var U=X("Network",{web:()=>Promise.resolve().then(()=>$e()).then(e=>new e.NetworkWeb)}),ze=void 0,Ke=void 0;class He{constructor(){this.clientId=this.getEnvironmentVariable("SF_CLIENT_ID"),this.clientSecret=this.getEnvironmentVariable("SF_CLIENT_SECRET"),this.redirectUri=this.getEnvironmentVariable("SF_REDIRECT_URI"),this.loginUrl=this.getEnvironmentVariable("SF_LOGIN_URL"),this.scope=this.getEnvironmentVariable("SF_SCOPE"),this.ACCESS_TOKEN_KEY="sf_access_token",this.REFRESH_TOKEN_KEY="sf_refresh_token",this.INSTANCE_URL_KEY="sf_instance_url",this.USER_ID_KEY="sf_user_id",console.log("Client ID:",this.clientId),console.log("Client Secret:",this.clientSecret),console.log("Redirect URI:",this.redirectUri),console.log("Login URL:",this.loginUrl),console.log("Scope:",this.scope),console.log("OAuthService initialized")}isLoggedIn(){const t=this.getStoredAccessToken(),s=this.getStoredRefreshToken(),r=this.getStoredInstanceUrl();return console.log("Checking login status:",{hasAccessToken:!!t,hasRefreshToken:!!s,hasInstanceUrl:!!r}),!!(t||s)&&!!r}getStoredAccessToken(){return sessionStorage.getItem(this.ACCESS_TOKEN_KEY)||localStorage.getItem(this.ACCESS_TOKEN_KEY)}getStoredRefreshToken(){return localStorage.getItem(this.REFRESH_TOKEN_KEY)}getStoredInstanceUrl(){return sessionStorage.getItem(this.INSTANCE_URL_KEY)||localStorage.getItem(this.INSTANCE_URL_KEY)}async startOAuthFlow(){try{console.log("Starting OAuth flow...");const t=await this.buildAuthorizationUrl();if(console.log("OAuth URL:",t),window.Capacitor){console.log("Capacitor detected, attempting to open browser...");try{const{Browser:s}=await we("@capacitor/browser/v/7_0_2");console.log("Using Capacitor Browser plugin"),await s.open({url:t,windowName:"_blank",toolbarColor:"#667eea",presentationStyle:"fullscreen"}),console.log("Browser opened successfully with Capacitor plugin")}catch(s){console.log("Capacitor Browser not available, trying alternative methods..."),console.error("Browser plugin error:",s),window.open?(console.log("Trying window.open with _blank target"),window.open(t,"_blank","location=yes,toolbar=yes")||(console.log("Popup blocked, trying _system target"),window.open(t,"_system"))):(console.log("window.open not available, using location.href"),window.location.href=t)}}else console.log("Not in Capacitor, using direct redirect"),window.location.href=t}catch(t){throw console.error("Error starting OAuth flow:",t),new Error("Failed to start OAuth authorization: "+t.message)}}async buildAuthorizationUrl(){const t=this.generateState();console.log("Generated OAuth state:",t);const s=this.generateCodeVerifier(),r=await this.generateCodeChallenge(s);sessionStorage.setItem("oauth_code_verifier",s);const n=new URLSearchParams({response_type:"code",client_id:this.clientId,redirect_uri:this.redirectUri,scope:this.scope,state:t,code_challenge:r,code_challenge_method:"S256",display:"touch",prompt:"login"}),i=`${this.loginUrl}/services/oauth2/authorize?${n.toString()}`;return console.log("=== SALESFORCE OAUTH CONFIGURATION ==="),console.log("Login URL:",this.loginUrl),console.log("Client ID:",this.clientId),console.log("Redirect URI:",this.redirectUri),console.log("Scope:",this.scope),console.log("State:",t),console.log("Code Challenge:",r),console.log("Full Authorization URL:",i),console.log("========================================="),i}generateCodeVerifier(){const t=new Uint8Array(32);return window.crypto.getRandomValues(t),this.base64URLEncode(t)}async generateCodeChallenge(t){const r=new TextEncoder().encode(t),n=await window.crypto.subtle.digest("SHA-256",r);return this.base64URLEncode(new Uint8Array(n))}base64URLEncode(t){return btoa(String.fromCharCode.apply(null,t)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async handleOAuthCallback(t,s){try{console.log("Handling OAuth callback:",{authorizationCode:t,state:s});const r=sessionStorage.getItem("oauth_state");if(console.log("Stored state:",r,"Received state:",s),s!==r)throw new Error("Invalid state parameter - possible CSRF attack");console.log("Exchanging code for tokens...");const n=await this.exchangeCodeForTokens(t);console.log("Token exchange successful:",{hasAccessToken:!!n.access_token,hasRefreshToken:!!n.refresh_token,instanceUrl:n.instance_url}),this.storeTokens(n);const i=await this.initializeConnection();return{success:!0,connection:i,userInfo:n}}catch(r){throw console.error("OAuth callback error:",r),r}finally{sessionStorage.removeItem("oauth_state")}}async exchangeCodeForTokens(t){const s=`${this.loginUrl}/services/oauth2/token`,r=sessionStorage.getItem("oauth_code_verifier"),n={grant_type:"authorization_code",client_id:this.clientId,client_secret:this.clientSecret,redirect_uri:this.redirectUri,code:t,code_verifier:r},i={method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:new URLSearchParams(n)};console.log("Making token exchange request to:",s),console.log("Token request data:",{grant_type:n.grant_type,client_id:n.client_id,redirect_uri:n.redirect_uri,code:t?"present":"missing",code_verifier:r?"present":"missing"});try{const o=await fetch(s,i);if(console.log("Token response status:",o.status),!o.ok){const a=await o.text();throw console.error("Token exchange failed on primary host:",a),new Error(a||"Primary token exchange failed")}return sessionStorage.removeItem("oauth_code_verifier"),o.json()}catch(o){if(this.loginUrl.includes(".my.site.com")){const l=`${this.loginUrl.replace(".my.site.com",".my.salesforce.com")}/services/oauth2/token`;console.log("Retrying token exchange via My Domain host:",l);try{const h=await fetch(l,i);if(console.log("Fallback token response status:",h.status),!h.ok){const f=await h.text();throw console.error("Fallback token exchange failed:",f),new Error(f||"Fallback token exchange failed")}return sessionStorage.removeItem("oauth_code_verifier"),h.json()}catch(h){throw console.error("Token exchange failed after fallback:",h),new Error(`Token exchange failed on both hosts: ${h.message||h}`)}}throw new Error(o.message||"Token exchange failed")}}storeTokens(t){if(console.log("\u{1F510} Storing tokens..."),console.log("\u{1F510} Token response structure:",{has_access_token:!!t.access_token,has_refresh_token:!!t.refresh_token,has_instance_url:!!t.instance_url,has_id:!!t.id}),sessionStorage.setItem(this.ACCESS_TOKEN_KEY,t.access_token),sessionStorage.setItem(this.INSTANCE_URL_KEY,t.instance_url),t.refresh_token?(localStorage.setItem(this.REFRESH_TOKEN_KEY,t.refresh_token),console.log("\u{1F510} Refresh token stored in localStorage")):console.warn("\u26A0\uFE0F No refresh token in response - this might cause issues on app restart"),localStorage.setItem(this.INSTANCE_URL_KEY,t.instance_url),t.id){const s=t.id.match(/\/([a-zA-Z0-9]{15,18})$/);if(s){const r=s[1];sessionStorage.setItem(this.USER_ID_KEY,r),localStorage.setItem(this.USER_ID_KEY,r),console.log("\u{1F510} Stored user ID:",r)}}console.log("\u2705 Tokens stored successfully")}async initializeConnection(){console.log("Initializing JSForce connection...");const t=this.getStoredAccessToken(),s=this.getStoredRefreshToken(),r=this.getStoredInstanceUrl();if(!r)throw new Error("No instance URL found");const n=window.jsforce;if(!n)throw new Error("JSForce library not loaded");const i=new n.Connection({oauth2:{clientId:this.clientId,clientSecret:this.clientSecret,redirectUri:this.redirectUri},instanceUrl:r,accessToken:t,refreshToken:s,version:"60.0"});return i.on("refresh",o=>{console.log("Access token refreshed automatically"),sessionStorage.setItem(this.ACCESS_TOKEN_KEY,o)}),!t&&s&&(console.log("No access token, refreshing using refresh token..."),await this.refreshAccessToken(i)),console.log("JSForce connection initialized successfully"),i}async refreshAccessToken(t=null){try{console.log("\u{1F504} Refreshing access token...");const s=this.getStoredRefreshToken(),r=this.getStoredInstanceUrl();if(!s)throw new Error("No refresh token available");if(!r)throw new Error("No instance URL available");console.log("\u{1F504} Using refresh token to get new access token..."),console.log("\u{1F504} Instance URL:",r);const n=`${r}/services/oauth2/token`,i={grant_type:"refresh_token",refresh_token:s,client_id:this.clientId};this.clientSecret?(i.client_secret=this.clientSecret,console.log("\u{1F504} Using client secret for token refresh")):console.log("\u{1F504} No client secret - using public client flow");const o=new URLSearchParams(i),a=await fetch(n,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:o.toString()});if(!a.ok){const h=await a.text();throw console.error("\u{1F504} Token refresh HTTP error:",a.status,h),new Error(`Token refresh failed: ${a.status} ${h}`)}const l=await a.json();return console.log("\u{1F504} Token refresh successful:",{access_token:l.access_token?"present":"missing",instance_url:l.instance_url||"not returned",refresh_token:l.refresh_token?"new refresh token received":"no new refresh token"}),sessionStorage.setItem(this.ACCESS_TOKEN_KEY,l.access_token),l.instance_url&&(sessionStorage.setItem(this.INSTANCE_URL_KEY,l.instance_url),localStorage.setItem(this.INSTANCE_URL_KEY,l.instance_url)),l.refresh_token&&(localStorage.setItem(this.REFRESH_TOKEN_KEY,l.refresh_token),console.log("\u{1F504} New refresh token stored")),console.log("\u2705 Access token refreshed successfully"),l.access_token}catch(s){if(console.error("\u274C Token refresh failed:",s),s.message&&s.message.includes("400"))try{const r=s.message;if(console.error("\u{1F504} Detailed error:",r),r.includes("invalid_grant"))throw console.log("\u{1F504} Invalid grant error - refresh token might be revoked or expired"),this.clearTokens(),document.dispatchEvent(new CustomEvent("auth-logout",{detail:{reason:"refresh_token_expired",error:r}})),new Error("Your session has expired. Please log in again.")}catch(r){console.warn("Could not parse error details:",r)}throw s.message.includes("invalid_grant")||s.message.includes("expired")||s.message.includes("invalid_client")?(console.log("\u{1F504} Authentication error detected, clearing tokens"),this.clearTokens(),document.dispatchEvent(new CustomEvent("auth-logout",{detail:{reason:"auth_error",error:s.message}})),new Error("Session expired. Please log in again.")):new Error(`Token refresh failed: ${s.message}`)}}async getValidConnection(){try{if(console.log("Getting valid connection..."),!this.isLoggedIn())throw new Error("User not logged in");const t=await this.initializeConnection();return console.log("JSForce connection initialized, returning to AuthUtils for testing"),t}catch(t){throw console.error("Failed to get valid connection:",t),t}}clearTokens(){console.log("Clearing all tokens..."),sessionStorage.removeItem(this.ACCESS_TOKEN_KEY),sessionStorage.removeItem(this.INSTANCE_URL_KEY),sessionStorage.removeItem(this.USER_ID_KEY),localStorage.removeItem(this.REFRESH_TOKEN_KEY),localStorage.removeItem(this.INSTANCE_URL_KEY),localStorage.removeItem(this.USER_ID_KEY),console.log("All tokens cleared")}getEnvironmentVariable(t){if(window.Capacitor)try{if(window.Capacitor.getPlatform()==="android")try{if(window.AndroidConfig&&typeof window.AndroidConfig.getConfigValue=="function"){const r=window.AndroidConfig.getConfigValue(t);if(r)return r}}catch(r){console.error("Error accessing Android config:",r)}}catch(s){console.error("Error accessing environment variable:",s)}return console.error(`Environment variable ${t} not found`),null}generateState(){const t=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);return sessionStorage.setItem("oauth_state",t),t}async logout(){try{console.log("Logging out user...");const t=this.getStoredAccessToken();if(t){const s=`${this.getStoredInstanceUrl()}/services/oauth2/revoke`;await fetch(s,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:`token=${t}`}),console.log("Tokens revoked on server")}}catch(t){console.error("Error revoking token:",t)}finally{this.clearTokens(),console.log("Logout completed")}}}const Ye=ee(He,{tmpl:Ke,sel:"c-oauth-service",apiVersion:63});class Ge{constructor(){this.oauthService=new Ye,this._connectionPromise=null,this._lastConnectionTime=0,this._connectionCacheDuration=2*60*1e3}async getValidConnection(){const t=Date.now();if(this._connectionPromise&&t-this._lastConnectionTime<this._connectionCacheDuration)try{return await this._connectionPromise}catch(s){console.warn("Cached connection expired, creating new one:",s.message)}return this._connectionPromise=this._createValidConnection(),this._lastConnectionTime=t,this._connectionPromise}async _createValidConnection(){try{if(console.log("\u{1F510} AuthUtils: Creating valid connection..."),!this.hasAnyTokens())throw new Error("No authentication tokens found. Please login first.");const t=await this.oauthService.getValidConnection();try{return await t.query("SELECT Id FROM User LIMIT 1"),console.log("\u2705 AuthUtils: Connection test successful"),t}catch(s){if(console.warn("\u26A0\uFE0F AuthUtils: Connection test failed, attempting refresh...",s.message),s.errorCode==="INVALID_SESSION_ID"||s.message.includes("Session expired")||s.message.includes("expired access/refresh token")){console.log("\u{1F504} AuthUtils: Attempting token refresh due to session error"),this._connectionPromise=null,await this.oauthService.refreshAccessToken();const r=await this.oauthService.getValidConnection();return await r.query("SELECT Id FROM User LIMIT 1"),console.log("\u2705 AuthUtils: New connection after refresh successful"),r}throw s}}catch(t){throw console.error("\u274C AuthUtils: Failed to create valid connection:",t),this.isTokenExpiredError(t)?(console.log("\u{1F504} AuthUtils: Tokens expired, clearing stored tokens"),this.oauthService.clearTokens(),this.dispatchLogoutEvent(),new Error("Session expired. Please log in again.")):t}}hasAnyTokens(){const t=sessionStorage.getItem("sf_access_token")||localStorage.getItem("sf_access_token"),s=localStorage.getItem("sf_refresh_token"),r=sessionStorage.getItem("sf_instance_url")||localStorage.getItem("sf_instance_url");return!!(t||s)&&!!r}isTokenExpiredError(t){const s=t.message?.toLowerCase()||"",r=t.errorCode?.toLowerCase()||"";return s.includes("invalid_grant")||s.includes("expired")||s.includes("session expired")||r==="invalid_session_id"||r==="invalid_grant"}dispatchLogoutEvent(){try{const t=new CustomEvent("auth-logout",{bubbles:!0,composed:!0,detail:{reason:"token_expired"}});typeof document!="undefined"&&document.dispatchEvent(t)}catch(t){console.warn("Failed to dispatch logout event:",t)}}async ensureAuthenticated(){try{return await this.getValidConnection(),!0}catch(t){return console.error("Authentication check failed:",t),!1}}async getConnectionForComponent(){try{return await this.getValidConnection()}catch(t){throw new Error(`Not authenticated. ${t.message}`)}}clearConnectionCache(){this._connectionPromise=null,this._lastConnectionTime=0,console.log("\u{1F504} AuthUtils: Connection cache cleared")}forceLogout(){console.log("\u{1F510} AuthUtils: Force logout - clearing all caches and tokens"),this.clearConnectionCache(),this.oauthService.clearTokens()}isLoggedIn(){return this.oauthService.isLoggedIn()}getTokenInfo(){return{hasAccessToken:!!sessionStorage.getItem("sf_access_token"),hasRefreshToken:!!localStorage.getItem("sf_refresh_token"),hasInstanceUrl:!!sessionStorage.getItem("sf_instance_url"),instanceUrl:sessionStorage.getItem("sf_instance_url")}}}const Qe=new Ge,z=ee(Qe,{tmpl:ze,sel:"c-auth-utils",apiVersion:63});async function K(){return await z.getConnectionForComponent()}const de=async(e,t)=>{try{const s=await K();console.log(`Getting customer and supplier info for record ID: ${t}`);const r={customerName:null,supplierName:null,accountType:null,accountId:null,objectLabel:null},n="_Personal_Files";console.log("conn",s);let i=sessionStorage.getItem("sf_user_id");i||(i=localStorage.getItem("sf_user_id")),console.log("userId",i);const o=await s.sobject(e).describe();r.objectLabel=o.label.replace(/ /g,"_"),console.log("result.objectLabel",r.objectLabel);const a=`
            SELECT Id, ContactId, Email, Rhythm__Default_Location__c
            FROM User
            WHERE Id = '${i}'
            LIMIT 1
        `,l=await s.query(a);if(console.log("userRecords",JSON.stringify(l)),l.records.length>0&&l.records[0].ContactId&&l.records[0].Rhythm__Default_Location__c){const h=`
                SELECT Id
                FROM Rhythm__Location__c
                WHERE Id = '${l.records[0].Rhythm__Default_Location__c}'
            `,f=await s.query(h);console.log("locationRecords",JSON.stringify(f)),f.records.length>0&&(r.accountId=f.records[0].Id,r.accountType="Location Lite User")}if(r.accountType||(r.accountType="Admin"),console.log("result",JSON.stringify(r)),r.accountType==="Admin"||r.accountType==="Location Lite User"){let h="",f="";const u=`
                SELECT Id, Rhythm__Supplier_Id__c  
                FROM Rhythm__Supplier_Objects__mdt
                WHERE Rhythm__Object_Api_Name__c = '${e}' AND Rhythm__Is_Supplier_Contact__c = false
                LIMIT 1
            `,d=await s.query(u);console.log("metadataRecords",JSON.stringify(d)),d.records.length>0&&(h=d.records[0].Rhythm__Supplier_Id__c);const y=`SELECT Id, ${h} FROM ${e} WHERE Id = '${t}'`,g=await s.query(y);console.log("queryRecords",JSON.stringify(g)),g.records.length>0&&(f=g.records[0][h]);const w=`SELECT Id, Name FROM Rhythm__Location__c WHERE Id = '${f}'`,c=await s.query(w);if(console.log("locationRecords",JSON.stringify(c)),c.records.length>0){const p=c.records[0].Name;r.customerName=p.replace(/ /g,"_"),r.supplierName=`${r.customerName}${n}`}}return console.log("\u2705 Customer and supplier info response:",r),r}catch(s){throw console.error("Error getting customer and supplier info:",s),s}};async function ue(){const e=await K(),t=`
        SELECT Id, Name FROM Network LIMIT 1
    `,s=await e.query(t);return s.records.length>0?s.records[0]:null}async function he(){try{const e=await K(),t=`
            SELECT Id, DeveloperName,
                   Rhythm__customValue__c
            FROM Rhythm__S3Configuration__mdt
            WHERE DeveloperName = 'type'
            LIMIT 1
        `,s=await e.query(t);return s.records.length>0?s.records[0]:null}catch(e){return console.error("Error getting S3 configuration:",e),null}}async function Ze(e,t){try{try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(E){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}console.log("\u{1F680} Starting uploadFileToSalesforce with fileRecord:",JSON.stringify(e));const s=new FileReader,r=new Promise((E,S)=>{s.onloadend=()=>{const P=s.result.split(",")[1];E(P)},s.onerror=()=>S(new Error("Failed to read file as base64"))});s.readAsDataURL(t);const n=await r;console.log("\u{1F4C4} Converted file to base64, length:",n.length);const i=await z.getConnectionForComponent();let o=e.name,a=o.lastIndexOf("."),l=a!==-1?o.slice(0,a):o,h=a!==-1?o.slice(a):"";l=l.replace(/[^a-zA-Z0-9]+/g,"_"),l=l.replace(/^_+|_+$/g,"");const f=l+h,u=new Date().toISOString().replace(/[-:]/g,"").split(".")[0],d=`${e.recordId}_${u}_${f}`;console.log("\u{1F4C4} Creating ContentVersion record with filename:",d);const y=await ue();console.log("\u{1F4E4} Using JSForce to create ContentVersion"),console.log("Using direct base64 upload approach");const g={Title:d,PathOnClient:d,VersionData:n,FirstPublishLocationId:e.recordId,Description:e.description||"",NetworkId:y?.Id,ContentLocation:"S"};console.log("Creating ContentVersion with base64 data"),console.log("Base64 data length:",n.length);const w=await i.sobject("ContentVersion").create(g);if(!w.success)throw console.error("\u274C Failed to create ContentVersion:",w),new Error(`Failed to create ContentVersion: ${w.errors?.join(", ")}`);console.log("\u2705 ContentVersion created successfully with direct base64 upload, ID:",w.id);const c=w.id,b=(await i.query(`SELECT Id, ContentDocumentId FROM ContentVersion WHERE Id = '${c}'`)).records[0]?.ContentDocumentId;return console.log("\u2705 ContentDocument ID:",b),{success:!0,fileSize:t.size,fileName:d,contentVersionId:c,contentDocumentId:b,uploadType:"salesforce"}}catch(s){return console.error("\u274C uploadFileToSalesforce error:",s),{success:!1,error:s.message||s,uploadType:"salesforce"}}}async function et(e){try{try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(c){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}const t=await he();if(console.log("\u{1F50D} S3 Configuration:",t),t&&t.Rhythm__customValue__c==="salesforce"?console.log("\u{1F4C1} Using Salesforce standard file upload method"):console.log("\u{1F4C1} Using S3 file upload method"),console.log("\u{1F680} Starting uploadFileToS3 with fileRecord:",e),!e||!e.webPath)throw new Error("\u274C No webPath in fileRecord");let s=e.name;const r=e.type||"image/jpeg";let n=s.lastIndexOf("."),i=n!==-1?s.slice(0,n):s,o=n!==-1?s.slice(n):"";i=i.replace(/[^a-zA-Z0-9]+/g,"_"),i=i.replace(/^_+|_+$/g,"");const a=i+o,l=new Date().toISOString().replace(/[-:]/g,"").split(".")[0];console.log("fileRecord in line 59",JSON.stringify(e));let h="";if(e.recordId&&e.formType)try{console.log("Getting customer and supplier info for folder path");const c=await de(e.formType,e.recordId);console.log("customerAndSupplierInfo",c),c&&c.supplierName&&c.supplierName.includes("_Personal_Files")&&(h=`${c.customerName}/${c.objectLabel}/${c.supplierName}`,console.log("folderName",h))}catch(c){console.error("Error getting customer and supplier info:",c)}const f=`${e.recordId}_${l}_${a}`;console.log("\u{1F50D} Getting presigned URL with fileName:",f),console.log("\u{1F4C2} FileRecord details:",{name:e.name,webPath:e.webPath,type:e.type,folderPath:h}),console.log("folderPath",h);try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(c){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}let u;if(!t||t.Rhythm__customValue__c!=="salesforce"){const c=await fetch("https://i3keec7y9j.execute-api.ap-south-1.amazonaws.com/default/preSignedUrl",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({filePath:`${h}/${f}`,type:"upload"})});if(console.log("\u{1F4E5} Presigned URL response status:",JSON.stringify(c)),!c.ok)throw new Error(`\u274C Failed to get presigned URL: ${c.status}`);const p=await c.json();if(console.log("\u{1F4DD} Raw Lambda response:",p),typeof p=="string")u=p,console.log("\u{1F517} Lambda returned URL directly as string");else if(p.url)u=p.url,console.log("\u{1F517} Lambda returned URL in object.url property");else if(p.uploadURL)u=p.uploadURL,console.log("\u{1F517} Lambda returned URL in object.uploadURL property");else throw console.error("\u274C Could not find URL in response:",p),new Error("\u274C No valid presigned URL found in Lambda response");console.log("\u{1F517} Using presigned URL:",u)}let d;if(e.webPath.startsWith("data:")){console.log("\u{1F4C4} Processing data URL...");const c=e.webPath.split(",");if(c.length===2){const p=c[1];console.log("\u{1F4C4} Extracted base64 from data URL, length:",p.length);const b=atob(p),E=new Uint8Array(b.length);for(let S=0;S<b.length;S++)E[S]=b.charCodeAt(S);d=new Blob([E],{type:r}),console.log("\u{1F4C4} Created blob from base64, size:",d.size,"bytes")}else throw new Error("\u274C Invalid data URL format")}else{console.log("\u{1F4C2} Processing file path..."),console.log("\u{1F4C2} Original webPath:",e.webPath);let c;e.webPath.startsWith("file://")?(c=e.webPath.replace("file://",""),console.log("\u{1F4C2} Extracted file:// path:",c)):e.webPath.startsWith("http")?(c=new URL(e.webPath).pathname.replace("/_capacitor_file_/",""),console.log("\u{1F4C2} Extracted webPath:",c)):(c=e.webPath,console.log("\u{1F4C2} Using direct path:",c)),console.log("\u{1F4D6} Reading file using Filesystem API...");const p=await ie.readFile({path:c}),b=p.data.includes(",")?p.data.split(",")[1]:p.data;console.log("\u{1F4C4} Base64 data length:",b.length),console.log("\u{1F4C4} Base64 starts with:",b.slice(0,20));const E=atob(b),S=new Uint8Array(E.length);for(let P=0;P<E.length;P++)S[P]=E.charCodeAt(P);d=new Blob([S],{type:r}),console.log("\u{1F4C4} Created blob from file data, size:",d.size,"bytes")}if(console.log("\u{1F4E6} Final blob details:"),console.log("\u{1F4E6} Blob size:",d.size,"bytes"),console.log("\u{1F4E6} Blob type:",d.type),d.size===0)throw new Error("\u{1F6AB} Blob size is zero \u2014 image data corrupted");try{const c=await d.arrayBuffer(),p=new Uint8Array(c);console.log("\u{1F50D} Blob content verification:"),console.log("\u{1F50D} First 10 bytes (should start with FFD8 for JPEG):",Array.from(p.slice(0,10))),console.log("\u{1F50D} Last 10 bytes:",Array.from(p.slice(-10))),p[0]===255&&p[1]===216?console.log("\u2705 Blob contains valid JPEG signature"):console.warn("\u26A0\uFE0F Blob does not contain JPEG signature, got:",p[0],p[1]);const b=URL.createObjectURL(d),E=new Image;E.onload=()=>{console.log("\u2705 Blob creates loadable image"),URL.revokeObjectURL(b)},E.onerror=()=>{console.error("\u274C Blob does not create loadable image"),URL.revokeObjectURL(b)},E.src=b}catch(c){console.error("\u274C Failed to test blob content:",c)}console.log("\u{1F4E6} Creating File object...");const y=new File([d],f,{type:r});console.log("\u{1F4E6} File object created:"),console.log("\u{1F4E6} File object size:",y.size,"bytes"),console.log("\u{1F4E6} File object type:",y.type),console.log("\u{1F4E6} File object name:",y.name);try{const c=await y.arrayBuffer(),p=new Uint8Array(c,0,Math.min(10,c.byteLength));console.log("\u{1F4E6} File object first 10 bytes:",Array.from(p))}catch(c){console.error("\u274C Could not test File object content:",c)}if(t&&t.Rhythm__customValue__c==="salesforce")return await Ze(e,d);try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(c){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}const g=await fetch(u,{method:"PUT",body:y});if(console.log("\u{1F4E4} File object upload completed!"),console.log("\u{1F4E4} Response status:",g.status),console.log("\u{1F4E4} Response statusText:",g.statusText),console.log("\u{1F4E4} Response headers:",Object.fromEntries(g.headers.entries())),!g.ok){const c=await g.text();throw console.error("\u274C File object upload failed response body:",c),new Error(`\u274C File object upload failed with status ${g.status}: ${c}`)}const w=u.split("?")[0];return console.log("\u2705 SUCCESS! File object uploaded to S3"),console.log("\u2705 S3 URL:",w),console.log("\u2705 File size uploaded:",y.size,"bytes"),console.log(`\u{1F50D} Look for this exact file in AWS S3: ${h}/${f}`),{success:!0,fileSize:y.size,fileName:f,s3Url:w,s3Key:`${h}/${f}`}}catch(t){console.error("\u274C uploadFileToS3 error:",t);try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(s){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}return{success:!1,error:t.message||t}}}var pe=Object.defineProperty,tt=e=>pe(e,"__esModule",{value:!0}),st=(e,t)=>()=>(t||(t={exports:{}},e(t.exports,t)),t.exports),rt=(e,t)=>{for(var s in t)pe(e,s,{get:t[s],enumerable:!0})},nt=st(e=>{tt(e),rt(e,{CapacitorSQLiteWeb:()=>t});var t=class extends Q{constructor(){super(...arguments);this.jeepSqliteElement=null,this.isWebStoreOpen=!1}async initWebStore(){await customElements.whenDefined("jeep-sqlite"),this.jeepSqliteElement=document.querySelector("jeep-sqlite"),this.ensureJeepSqliteIsAvailable(),this.jeepSqliteElement.addEventListener("jeepSqliteImportProgress",s=>{this.notifyListeners("sqliteImportProgressEvent",s.detail)}),this.jeepSqliteElement.addEventListener("jeepSqliteExportProgress",s=>{this.notifyListeners("sqliteExportProgressEvent",s.detail)}),this.jeepSqliteElement.addEventListener("jeepSqliteHTTPRequestEnded",s=>{this.notifyListeners("sqliteHTTPRequestEndedEvent",s.detail)}),this.jeepSqliteElement.addEventListener("jeepSqlitePickDatabaseEnded",s=>{this.notifyListeners("sqlitePickDatabaseEndedEvent",s.detail)}),this.jeepSqliteElement.addEventListener("jeepSqliteSaveDatabaseToDisk",s=>{this.notifyListeners("sqliteSaveDatabaseToDiskEvent",s.detail)}),this.isWebStoreOpen||(this.isWebStoreOpen=await this.jeepSqliteElement.isStoreOpen())}async saveToStore(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.saveToStore(s);return}catch(r){throw new Error(`${r}`)}}async getFromLocalDiskToStore(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.getFromLocalDiskToStore(s);return}catch(r){throw new Error(`${r}`)}}async saveToLocalDisk(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.saveToLocalDisk(s);return}catch(r){throw new Error(`${r}`)}}async echo(s){return this.ensureJeepSqliteIsAvailable(),await this.jeepSqliteElement.echo(s)}async createConnection(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.createConnection(s);return}catch(r){throw new Error(`${r}`)}}async open(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.open(s);return}catch(r){throw new Error(`${r}`)}}async closeConnection(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.closeConnection(s);return}catch(r){throw new Error(`${r}`)}}async getVersion(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.getVersion(s)}catch(r){throw new Error(`${r}`)}}async checkConnectionsConsistency(s){this.ensureJeepSqliteIsAvailable();try{return await this.jeepSqliteElement.checkConnectionsConsistency(s)}catch(r){throw new Error(`${r}`)}}async close(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.close(s);return}catch(r){throw new Error(`${r}`)}}async beginTransaction(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.beginTransaction(s)}catch(r){throw new Error(`${r}`)}}async commitTransaction(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.commitTransaction(s)}catch(r){throw new Error(`${r}`)}}async rollbackTransaction(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.rollbackTransaction(s)}catch(r){throw new Error(`${r}`)}}async isTransactionActive(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.isTransactionActive(s)}catch(r){throw new Error(`${r}`)}}async getTableList(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.getTableList(s)}catch(r){throw new Error(`${r}`)}}async execute(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.execute(s)}catch(r){throw new Error(`${r}`)}}async executeSet(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.executeSet(s)}catch(r){throw new Error(`${r}`)}}async run(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.run(s)}catch(r){throw new Error(`${r}`)}}async query(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.query(s)}catch(r){throw new Error(`${r}`)}}async isDBExists(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.isDBExists(s)}catch(r){throw new Error(`${r}`)}}async isDBOpen(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.isDBOpen(s)}catch(r){throw new Error(`${r}`)}}async isDatabase(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.isDatabase(s)}catch(r){throw new Error(`${r}`)}}async isTableExists(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.isTableExists(s)}catch(r){throw new Error(`${r}`)}}async deleteDatabase(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.deleteDatabase(s);return}catch(r){throw new Error(`${r}`)}}async isJsonValid(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.isJsonValid(s)}catch(r){throw new Error(`${r}`)}}async importFromJson(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.importFromJson(s)}catch(r){throw new Error(`${r}`)}}async exportToJson(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.exportToJson(s)}catch(r){throw new Error(`${r}`)}}async createSyncTable(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.createSyncTable(s)}catch(r){throw new Error(`${r}`)}}async setSyncDate(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.setSyncDate(s);return}catch(r){throw new Error(`${r}`)}}async getSyncDate(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.getSyncDate(s)}catch(r){throw new Error(`${r}`)}}async deleteExportedRows(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.deleteExportedRows(s);return}catch(r){throw new Error(`${r}`)}}async addUpgradeStatement(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.addUpgradeStatement(s);return}catch(r){throw new Error(`${r}`)}}async copyFromAssets(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.copyFromAssets(s);return}catch(r){throw new Error(`${r}`)}}async getFromHTTPRequest(s){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{await this.jeepSqliteElement.getFromHTTPRequest(s);return}catch(r){throw new Error(`${r}`)}}async getDatabaseList(){this.ensureJeepSqliteIsAvailable(),this.ensureWebstoreIsOpen();try{return await this.jeepSqliteElement.getDatabaseList()}catch(s){throw new Error(`${s}`)}}ensureJeepSqliteIsAvailable(){if(this.jeepSqliteElement===null)throw new Error("The jeep-sqlite element is not present in the DOM! Please check the @capacitor-community/sqlite documentation for instructions regarding the web platform.")}ensureWebstoreIsOpen(){if(!this.isWebStoreOpen)throw new Error('WebStore is not open yet. You have to call "initWebStore()" first.')}async getUrl(){throw this.unimplemented("Not implemented on web.")}async getMigratableDbList(s){throw console.log("getMigratableDbList",s),this.unimplemented("Not implemented on web.")}async addSQLiteSuffix(s){throw console.log("addSQLiteSuffix",s),this.unimplemented("Not implemented on web.")}async deleteOldDatabases(s){throw console.log("deleteOldDatabases",s),this.unimplemented("Not implemented on web.")}async moveDatabasesAndAddSuffix(s){throw console.log("moveDatabasesAndAddSuffix",s),this.unimplemented("Not implemented on web.")}async isSecretStored(){throw this.unimplemented("Not implemented on web.")}async setEncryptionSecret(s){throw console.log("setEncryptionSecret",s),this.unimplemented("Not implemented on web.")}async changeEncryptionSecret(s){throw console.log("changeEncryptionSecret",s),this.unimplemented("Not implemented on web.")}async clearEncryptionSecret(){throw console.log("clearEncryptionSecret"),this.unimplemented("Not implemented on web.")}async checkEncryptionSecret(s){throw console.log("checkEncryptionPassPhrase",s),this.unimplemented("Not implemented on web.")}async getNCDatabasePath(s){throw console.log("getNCDatabasePath",s),this.unimplemented("Not implemented on web.")}async createNCConnection(s){throw console.log("createNCConnection",s),this.unimplemented("Not implemented on web.")}async closeNCConnection(s){throw console.log("closeNCConnection",s),this.unimplemented("Not implemented on web.")}async isNCDatabase(s){throw console.log("isNCDatabase",s),this.unimplemented("Not implemented on web.")}async isDatabaseEncrypted(s){throw console.log("isDatabaseEncrypted",s),this.unimplemented("Not implemented on web.")}async isInConfigEncryption(){throw this.unimplemented("Not implemented on web.")}async isInConfigBiometricAuth(){throw this.unimplemented("Not implemented on web.")}async loadExtension(s){throw console.log("loadExtension",s),this.unimplemented("Not implemented on web.")}async enableLoadExtension(s){throw console.log("enableLoadExtension",s),this.unimplemented("Not implemented on web.")}}});/*! Capacitor: https://capacitorjs.com/ - MIT License */var D;(function(e){e.Unimplemented="UNIMPLEMENTED",e.Unavailable="UNAVAILABLE"})(D||(D={}));var H=class extends Error{constructor(e,t,s){super(e);this.message=e,this.code=t,this.data=s}},ot=e=>{var t,s;return(e==null?void 0:e.androidBridge)?"android":((s=(t=e==null?void 0:e.webkit)===null||t===void 0?void 0:t.messageHandlers)===null||s===void 0?void 0:s.bridge)?"ios":"web"},it=e=>{const t=e.CapacitorCustomPlatform||null,s=e.Capacitor||{},r=s.Plugins=s.Plugins||{},n=()=>t!==null?t.name:ot(e),i=()=>n()!=="web",o=u=>{const d=h.get(u);return!!((d==null?void 0:d.platforms.has(n()))||a(u))},a=u=>{var d;return(d=s.PluginHeaders)===null||d===void 0?void 0:d.find(y=>y.name===u)},l=u=>e.console.error(u),h=new Map,f=(u,d={})=>{const y=h.get(u);if(y)return console.warn(`Capacitor plugin "${u}" already registered. Cannot register plugins twice.`),y.proxy;const g=n(),w=a(u);let c;const p=async()=>(!c&&g in d?c=typeof d[g]=="function"?c=await d[g]():c=d[g]:t!==null&&!c&&"web"in d&&(c=typeof d.web=="function"?c=await d.web():c=d.web),c),b=(m,_)=>{var v,C;if(w){const I=w==null?void 0:w.methods.find(T=>_===T.name);if(I)return I.rtype==="promise"?T=>s.nativePromise(u,_.toString(),T):(T,L)=>s.nativeCallback(u,_.toString(),T,L);if(m)return(v=m[_])===null||v===void 0?void 0:v.bind(m)}else{if(m)return(C=m[_])===null||C===void 0?void 0:C.bind(m);throw new H(`"${u}" plugin is not implemented on ${g}`,D.Unimplemented)}},E=m=>{let _;const v=(...C)=>{const I=p().then(T=>{const L=b(T,m);if(L){const A=L(...C);return _=A==null?void 0:A.remove,A}else throw new H(`"${u}.${m}()" is not implemented on ${g}`,D.Unimplemented)});return m==="addListener"&&(I.remove=async()=>_()),I};return v.toString=()=>`${m.toString()}() { [capacitor code] }`,Object.defineProperty(v,"name",{value:m,writable:!1,configurable:!1}),v},S=E("addListener"),P=E("removeListener"),$=(m,_)=>{const v=S({eventName:m},_),C=async()=>{const T=await v;P({eventName:m,callbackId:T},_)},I=new Promise(T=>v.then(()=>T({remove:C})));return I.remove=async()=>{console.warn("Using addListener() without 'await' is deprecated."),await C()},I},N=new Proxy({},{get(m,_){switch(_){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return w?$:S;case"removeListener":return P;default:return E(_)}}});return r[u]=N,h.set(u,{name:u,proxy:N,platforms:new Set([...Object.keys(d),...w?[g]:[]])}),N};return s.convertFileSrc||(s.convertFileSrc=u=>u),s.getPlatform=n,s.handleError=l,s.isNativePlatform=i,s.isPluginAvailable=o,s.registerPlugin=f,s.Exception=H,s.DEBUG=!!s.DEBUG,s.isLoggingEnabled=!!s.isLoggingEnabled,s},at=e=>e.Capacitor=it(e),Y=at(typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:typeof globalThis!="undefined"?globalThis:{}),G=Y.registerPlugin,Q=class{constructor(){this.listeners={},this.retainedEventArguments={},this.windowListeners={}}addListener(e,t){let s=!1;this.listeners[e]||(this.listeners[e]=[],s=!0),this.listeners[e].push(t);const n=this.windowListeners[e];n&&!n.registered&&this.addWindowListener(n),s&&this.sendRetainedArgumentsForEvent(e);const i=async()=>this.removeListener(e,t);return Promise.resolve({remove:i})}async removeAllListeners(){this.listeners={};for(const e in this.windowListeners)this.removeWindowListener(this.windowListeners[e]);this.windowListeners={}}notifyListeners(e,t,s){const r=this.listeners[e];if(!r){if(s){let n=this.retainedEventArguments[e];n||(n=[]),n.push(t),this.retainedEventArguments[e]=n}return}r.forEach(n=>n(t))}hasListeners(e){var t;return!!((t=this.listeners[e])===null||t===void 0?void 0:t.length)}registerWindowListener(e,t){this.windowListeners[t]={registered:!1,windowEventName:e,pluginEventName:t,handler:s=>{this.notifyListeners(t,s)}}}unimplemented(e="not implemented"){return new Y.Exception(e,D.Unimplemented)}unavailable(e="not available"){return new Y.Exception(e,D.Unavailable)}async removeListener(e,t){const s=this.listeners[e];if(!s)return;const r=s.indexOf(t);this.listeners[e].splice(r,1),this.listeners[e].length||this.removeWindowListener(this.windowListeners[e])}addWindowListener(e){window.addEventListener(e.windowEventName,e.handler),e.registered=!0}removeWindowListener(e){!e||(window.removeEventListener(e.windowEventName,e.handler),e.registered=!1)}sendRetainedArgumentsForEvent(e){const t=this.retainedEventArguments[e];!t||(delete this.retainedEventArguments[e],t.forEach(s=>{this.notifyListeners(e,s)}))}},fe=e=>encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape),ge=e=>e.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent),ct=class extends Q{async getCookies(){const e=document.cookie,t={};return e.split(";").forEach(s=>{if(s.length<=0)return;let[r,n]=s.replace(/=/,"CAP_COOKIE").split("CAP_COOKIE");r=ge(r).trim(),n=ge(n).trim(),t[r]=n}),t}async setCookie(e){try{const t=fe(e.key),s=fe(e.value),r=`; expires=${(e.expires||"").replace("expires=","")}`,n=(e.path||"/").replace("path=",""),i=e.url!=null&&e.url.length>0?`domain=${e.url}`:"";document.cookie=`${t}=${s||""}${r}; path=${n}; ${i};`}catch(t){return Promise.reject(t)}}async deleteCookie(e){try{document.cookie=`${e.key}=; Max-Age=0`}catch(t){return Promise.reject(t)}}async clearCookies(){try{const e=document.cookie.split(";")||[];for(const t of e)document.cookie=t.replace(/^ +/,"").replace(/=.*/,`=;expires=${new Date().toUTCString()};path=/`)}catch(e){return Promise.reject(e)}}async clearAllCookies(){try{await this.clearCookies()}catch(e){return Promise.reject(e)}}};G("CapacitorCookies",{web:()=>new ct});var lt=async e=>new Promise((t,s)=>{const r=new FileReader;r.onload=()=>{const n=r.result;t(n.indexOf(",")>=0?n.split(",")[1]:n)},r.onerror=n=>s(n),r.readAsDataURL(e)}),dt=(e={})=>{const t=Object.keys(e);return Object.keys(e).map(n=>n.toLocaleLowerCase()).reduce((n,i,o)=>(n[i]=e[t[o]],n),{})},ut=(e,t=!0)=>e?Object.entries(e).reduce((r,n)=>{const[i,o]=n;let a,l;return Array.isArray(o)?(l="",o.forEach(h=>{a=t?encodeURIComponent(h):h,l+=`${i}=${a}&`}),l.slice(0,-1)):(a=t?encodeURIComponent(o):o,l=`${i}=${a}`),`${r}&${l}`},"").substr(1):null,ht=(e,t={})=>{const s=Object.assign({method:e.method||"GET",headers:e.headers},t),n=dt(e.headers)["content-type"]||"";if(typeof e.data=="string")s.body=e.data;else if(n.includes("application/x-www-form-urlencoded")){const i=new URLSearchParams;for(const[o,a]of Object.entries(e.data||{}))i.set(o,a);s.body=i.toString()}else if(n.includes("multipart/form-data")||e.data instanceof FormData){const i=new FormData;if(e.data instanceof FormData)e.data.forEach((a,l)=>{i.append(l,a)});else for(const a of Object.keys(e.data))i.append(a,e.data[a]);s.body=i;const o=new Headers(s.headers);o.delete("content-type"),s.headers=o}else(n.includes("application/json")||typeof e.data=="object")&&(s.body=JSON.stringify(e.data));return s},pt=class extends Q{async request(e){const t=ht(e,e.webFetchExtra),s=ut(e.params,e.shouldEncodeUrlParams),r=s?`${e.url}?${s}`:e.url,n=await fetch(r,t),i=n.headers.get("content-type")||"";let{responseType:o="text"}=n.ok?e:{};i.includes("application/json")&&(o="json");let a,l;switch(o){case"arraybuffer":case"blob":l=await n.blob(),a=await lt(l);break;case"json":a=await n.json();break;case"document":case"text":default:a=await n.text()}const h={};return n.headers.forEach((f,u)=>{h[u]=f}),{data:a,headers:h,status:n.status,url:n.url}}async get(e){return this.request(Object.assign(Object.assign({},e),{method:"GET"}))}async post(e){return this.request(Object.assign(Object.assign({},e),{method:"POST"}))}async put(e){return this.request(Object.assign(Object.assign({},e),{method:"PUT"}))}async patch(e){return this.request(Object.assign(Object.assign({},e),{method:"PATCH"}))}async delete(e){return this.request(Object.assign(Object.assign({},e),{method:"DELETE"}))}};G("CapacitorHttp",{web:()=>new pt});var ft=class{constructor(e){this.sqlite=e,this._connectionDict=new Map}async initWebStore(){try{return await this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToStore(e){try{return await this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async saveToLocalDisk(e){try{return await this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getFromLocalDiskToStore(e){const t=e??!0;try{return await this.sqlite.getFromLocalDiskToStore({overwrite:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async echo(e){try{const t=await this.sqlite.echo({value:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isSecretStored(){try{const e=await this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async setEncryptionSecret(e){try{return await this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async changeEncryptionSecret(e,t){try{return await this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async clearEncryptionSecret(){try{return await this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}}async checkEncryptionSecret(e){try{const t=await this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async addUpgradeStatement(e,t){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async createConnection(e,t,s,r,n){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.createConnection({database:e,encrypted:t,mode:s,version:r,readonly:n});const i=new ye(e,n,this.sqlite),o=n?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(o,i),Promise.resolve(i)}catch(i){return Promise.reject(i)}}async closeConnection(e,t){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.closeConnection({database:e,readonly:t});const s=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(s),Promise.resolve()}catch(s){return Promise.reject(s)}}async isConnection(e,t){const s={};e.endsWith(".db")&&(e=e.slice(0,-3));const r=t?`RO_${e}`:`RW_${e}`;return s.result=this._connectionDict.has(r),Promise.resolve(s)}async retrieveConnection(e,t){e.endsWith(".db")&&(e=e.slice(0,-3));const s=t?`RO_${e}`:`RW_${e}`;if(this._connectionDict.has(s)){const r=this._connectionDict.get(s);return typeof r!="undefined"?Promise.resolve(r):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async getNCDatabasePath(e,t){try{const s=await this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async createNCConnection(e,t){try{await this.sqlite.createNCConnection({databasePath:e,version:t});const s=new ye(e,!0,this.sqlite),r=`RO_${e})`;return this._connectionDict.set(r,s),Promise.resolve(s)}catch(s){return Promise.reject(s)}}async closeNCConnection(e){try{await this.sqlite.closeNCConnection({databasePath:e});const t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(t){return Promise.reject(t)}}async isNCConnection(e){const t={},s=`RO_${e})`;return t.result=this._connectionDict.has(s),Promise.resolve(t)}async retrieveNCConnection(e){if(this._connectionDict.has(e)){const t=`RO_${e})`,s=this._connectionDict.get(t);return typeof s!="undefined"?Promise.resolve(s):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async isNCDatabase(e){try{const t=await this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async retrieveAllConnections(){return this._connectionDict}async closeAllConnections(){const e=new Map;try{for(const t of this._connectionDict.keys()){const s=t.substring(3),r=t.substring(0,3)==="RO_";await this.sqlite.closeConnection({database:s,readonly:r}),e.set(t,null)}for(const t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(t){return Promise.reject(t)}}async checkConnectionsConsistency(){try{const e=[...this._connectionDict.keys()],t=[],s=[];for(const n of e)t.push(n.substring(0,2)),s.push(n.substring(3));const r=await this.sqlite.checkConnectionsConsistency({dbNames:s,openModes:t});return r.result||(this._connectionDict=new Map),Promise.resolve(r)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}}async importFromJson(e){try{const t=await this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isJsonValid(e){try{const t=await this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async copyFromAssets(e){const t=e??!0;try{return await this.sqlite.copyFromAssets({overwrite:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async getFromHTTPRequest(e,t){const s=t??!0;try{return await this.sqlite.getFromHTTPRequest({url:e,overwrite:s}),Promise.resolve()}catch(r){return Promise.reject(r)}}async isDatabaseEncrypted(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isInConfigEncryption(){try{const e=await this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isInConfigBiometricAuth(){try{const e=await this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isDatabase(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async getDatabaseList(){try{const t=(await this.sqlite.getDatabaseList()).values;t.sort();const s={values:t};return Promise.resolve(s)}catch(e){return Promise.reject(e)}}async getMigratableDbList(e){const t=e||"default";try{const s=await this.sqlite.getMigratableDbList({folderPath:t});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async addSQLiteSuffix(e,t){const s=e||"default",r=t||[];try{const n=await this.sqlite.addSQLiteSuffix({folderPath:s,dbNameList:r});return Promise.resolve(n)}catch(n){return Promise.reject(n)}}async deleteOldDatabases(e,t){const s=e||"default",r=t||[];try{const n=await this.sqlite.deleteOldDatabases({folderPath:s,dbNameList:r});return Promise.resolve(n)}catch(n){return Promise.reject(n)}}async moveDatabasesAndAddSuffix(e,t){const s=e||"default",r=t||[];return this.sqlite.moveDatabasesAndAddSuffix({folderPath:s,dbNameList:r})}},ye=class{constructor(e,t,s){this.dbName=e,this.readonly=t,this.sqlite=s}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}async open(){try{return await this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async close(){try{return await this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async beginTransaction(){try{const e=await this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async commitTransaction(){try{const e=await this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async rollbackTransaction(){try{const e=await this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTransactionActive(){try{const e=await this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async loadExtension(e){try{return await this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async enableLoadExtension(e){try{return await this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getUrl(){try{const e=await this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getVersion(){try{const e=await this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getTableList(){try{const e=await this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async execute(e,t=!0,s=!0){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const r=await this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:s});return Promise.resolve(r)}}catch(r){return Promise.reject(r)}}async query(e,t,s=!0){let r;try{return t&&t.length>0?r=await this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):r=await this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:s}),r=await this.reorderRows(r),Promise.resolve(r)}catch(n){return Promise.reject(n)}}async run(e,t,s=!0,r="no",n=!0){let i;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(t&&t.length>0?i=await this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:s,readonly:!1,returnMode:r,isSQL92:!0}):i=await this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:s,readonly:!1,returnMode:r,isSQL92:n}),i.changes=await this.reorderRows(i.changes),Promise.resolve(i))}catch(o){return Promise.reject(o)}}async executeSet(e,t=!0,s="no",r=!0){let n;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(n=await this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:s,isSQL92:r}),n.changes=await this.reorderRows(n.changes),Promise.resolve(n))}catch(i){return Promise.reject(i)}}async isExists(){try{const e=await this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTable(e){try{const t=await this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isDBOpen(){try{const e=await this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async delete(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async createSyncTable(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const e=await this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}}async setSyncDate(e){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve())}catch(t){return Promise.reject(t)}}async getSyncDate(){try{const e=await this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly});let t="";return e.syncDate>0&&(t=new Date(e.syncDate*1e3).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}}async exportToJson(e,t=!1){try{const s=await this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async deleteExportedRows(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async executeTransaction(e,t=!0){let s=0,r=!1;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(await this.sqlite.beginTransaction({database:this.dbName}),r=await this.sqlite.isTransactionActive({database:this.dbName}),!r)return Promise.reject("After Begin Transaction, no transaction active");try{for(const o of e){if(typeof o!="object"||!("statement"in o))throw new Error("Error a task.statement must be provided");if("values"in o&&o.values&&o.values.length>0){const a=o.statement.toUpperCase().includes("RETURNING")?"all":"no",l=await this.sqlite.run({database:this.dbName,statement:o.statement,values:o.values,transaction:!1,readonly:!1,returnMode:a,isSQL92:t});if(l.changes.changes<0)throw new Error("Error in transaction method run ");s+=l.changes.changes}else{const a=await this.sqlite.execute({database:this.dbName,statements:o.statement,transaction:!1,readonly:!1});if(a.changes.changes<0)throw new Error("Error in transaction method execute ");s+=a.changes.changes}}s+=(await this.sqlite.commitTransaction({database:this.dbName})).changes.changes;const i={changes:{changes:s}};return Promise.resolve(i)}catch(n){const i=n.message?n.message:n;return await this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(i)}}async reorderRows(e){const t=e;if(e?.values&&typeof e.values[0]=="object"&&Object.keys(e.values[0]).includes("ios_columns")){const s=e.values[0].ios_columns,r=[];for(let n=1;n<e.values.length;n++){const i=e.values[n],o={};for(const a of s)o[a]=i[a];r.push(o)}t.values=r}return Promise.resolve(t)}},gt=G("CapacitorSQLite",{web:()=>Promise.resolve().then(()=>nt()).then(e=>new e.CapacitorSQLiteWeb),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite});class yt{constructor(){this.sqlite=new ft(gt),this.dbConnection=null,this.DB_NAME="salesforceOfflineDB",this.DB_VERSION=1,this.isInitialized=!1,this.initPromise=null}getTableSchemas(){return{metadata_cache:`
                CREATE TABLE IF NOT EXISTS metadata_cache (
                    id TEXT PRIMARY KEY,
                    object_api_name TEXT NOT NULL,
                    encrypted_data TEXT,
                    cached_at TEXT,
                    user_cache_id TEXT,
                    record_count INTEGER DEFAULT 0,
                    has_enhanced_schema INTEGER DEFAULT 0,
                    mobile_simple INTEGER DEFAULT 0,
                    mobile_complete INTEGER DEFAULT 0,
                    lookup_options TEXT,
                    picklist_options TEXT,
                    field_types TEXT,
                    field_records TEXT,
                    controlling_records TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,tabs:`
                CREATE TABLE IF NOT EXISTS tabs (
                    id TEXT PRIMARY KEY,
                    objectApiName TEXT NOT NULL,
                    label TEXT NOT NULL,
                    sortOrder INTEGER NOT NULL,
                    component TEXT NOT NULL,
                    parentId TEXT NULL,
                    propsJson TEXT NULL,
                    isActive INTEGER NOT NULL DEFAULT 1,
                    iconName TEXT NULL,
                    keepAlive INTEGER NULL DEFAULT 0,
                    prefetch INTEGER NULL DEFAULT 0,
                    isAttachment INTEGER NULL DEFAULT 0,
                    listViewObject TEXT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,metadata_version:`
                CREATE TABLE IF NOT EXISTS metadata_version (
                    name TEXT PRIMARY KEY,
                    version INTEGER NOT NULL,
                    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,safety_events:`
                CREATE TABLE IF NOT EXISTS safety_events (
                    id TEXT PRIMARY KEY,
                    object_type TEXT NOT NULL,
                    encrypted_data TEXT,
                    sync_status TEXT DEFAULT 'pending',
                    created_at TEXT,
                    attempts INTEGER DEFAULT 0,
                    last_attempt TEXT,
                    last_error TEXT,
                    created_offline INTEGER DEFAULT 1,
                    created_date DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,pending_operations:`
                CREATE TABLE IF NOT EXISTS pending_operations (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    operation_id TEXT UNIQUE,
                    type TEXT NOT NULL,
                    object_type TEXT,
                    timestamp INTEGER,
                    data TEXT,
                    attempts INTEGER DEFAULT 0,
                    last_attempt TEXT,
                    status TEXT DEFAULT 'pending',
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,file_uploads:`
                CREATE TABLE IF NOT EXISTS file_uploads (
                    id TEXT PRIMARY KEY,
                    form_type TEXT,
                    record_id TEXT,
                    form_temp_id TEXT,
                    file_name TEXT,
                    file_path TEXT,
                    file_size INTEGER,
                    mime_type TEXT,
                    upload_status TEXT DEFAULT 'pending',
                    folder_path TEXT,
                    s3_key TEXT,
                    s3_url TEXT,
                    retry_attempts INTEGER DEFAULT 0,
                    last_error TEXT,
                    related_record_id TEXT,
                    description TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,lookup_values:`
                CREATE TABLE IF NOT EXISTS lookup_values (
                    id TEXT PRIMARY KEY,
                    object_api_name TEXT NOT NULL,
                    field_api_name TEXT NOT NULL,
                    lookup_options TEXT,
                    cached_at TEXT,
                    user_cache_id TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,left_menu:`
                CREATE TABLE IF NOT EXISTS left_menu (
                    id TEXT PRIMARY KEY,
                    menu_items TEXT,
                    cached_at TEXT,
                    user_cache_id TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,fields_config:`
                CREATE TABLE IF NOT EXISTS fields_config (
                    id TEXT PRIMARY KEY,
                    object_api_name TEXT NOT NULL,
                    field_configs TEXT,
                    cached_at TEXT,
                    user_cache_id TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,list_view_records:`
                CREATE TABLE IF NOT EXISTS list_view_records (
                    id TEXT PRIMARY KEY,
                    object_api_name TEXT NOT NULL,
                    records TEXT,
                    cached_at TEXT,
                    user_cache_id TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,aws_s3_list:`
                CREATE TABLE IF NOT EXISTS aws_s3_list (
                    id TEXT PRIMARY KEY,
                    object_api_name TEXT NOT NULL,
                    records TEXT,
                    cached_at TEXT,
                    user_cache_id TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,accounts:`
                CREATE TABLE IF NOT EXISTS accounts (
                    id TEXT PRIMARY KEY,
                    name TEXT,
                    data TEXT,
                    sync_status TEXT DEFAULT 'synced',
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `,contacts:`
                CREATE TABLE IF NOT EXISTS contacts (
                    id TEXT PRIMARY KEY,
                    name TEXT,
                    email TEXT,
                    data TEXT,
                    sync_status TEXT DEFAULT 'synced',
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
            `}}async init(){return this.isInitialized?this.dbConnection:this.initPromise?this.initPromise:(this.initPromise=this._performInit(),this.initPromise)}async _performInit(){try{console.log("\u{1F527} Initializing SQLite database...");const t=this.getPlatform();return console.log("\u{1F4F1} Platform detected:",t),t==="web"&&(console.log("\u{1F310} Initializing web SQLite store..."),await this.sqlite.initWebStore()),(await this.sqlite.checkConnectionsConsistency()).result?this.dbConnection=await this.sqlite.retrieveConnection(this.DB_NAME,!1):this.dbConnection=await this.sqlite.createConnection(this.DB_NAME,!1,"no-encryption",this.DB_VERSION,!1),await this.dbConnection.open(),console.log("\u2705 SQLite database opened successfully"),await this.createTables(),this.isInitialized=!0,console.log("\u2705 SQLite service initialized successfully"),this.dbConnection}catch(t){throw console.error("\u274C Failed to initialize SQLite:",t),this.isInitialized=!1,this.initPromise=null,t}}async createTables(){try{console.log("\u{1F4CB} Creating SQLite tables...");const t=this.getTableSchemas();for(const[s,r]of Object.entries(t))await this.dbConnection.execute(r),console.log(`\u2705 Table created: ${s}`);await this.createIndexes(),console.log("\u2705 All tables and indexes created successfully")}catch(t){throw console.error("\u274C Failed to create tables:",t),t}}async createIndexes(){try{console.log("\u{1F4CB} Creating SQLite indexes...");const t=["CREATE INDEX IF NOT EXISTS idx_lookup_object_field ON lookup_values (object_api_name, field_api_name)","CREATE INDEX IF NOT EXISTS idx_metadata_object ON metadata_cache (object_api_name)","CREATE INDEX IF NOT EXISTS idx_safety_events_sync ON safety_events (sync_status)","CREATE INDEX IF NOT EXISTS idx_pending_operations_status ON pending_operations (status, type)","CREATE INDEX IF NOT EXISTS idx_fields_config_object ON fields_config (object_api_name)","CREATE INDEX IF NOT EXISTS idx_list_view_records_object ON list_view_records (object_api_name)","CREATE INDEX IF NOT EXISTS idx_aws_s3_list_object ON aws_s3_list (object_api_name)","CREATE INDEX IF NOT EXISTS idx_tabs_object ON tabs (objectApiName)","CREATE INDEX IF NOT EXISTS idx_tabs_parent ON tabs (parentId)","CREATE INDEX IF NOT EXISTS idx_tabs_active ON tabs (isActive)"];for(const s of t)await this.dbConnection.execute(s),console.log(`\u2705 Index created: ${s.split(" ")[5]}`);console.log("\u2705 All indexes created successfully")}catch(t){console.error("\u274C Failed to create indexes:",t)}}getPlatform(){return window.Capacitor?window.Capacitor.getPlatform():"web"}async saveItem(t,s){try{await this.init();const n=this.getTableMapping()[t]||t.toLowerCase();return n==="metadata_cache"?this.saveMetadataItem(s):n==="safety_events"?this.saveSafetyEventItem(s):n==="pending_operations"?this.savePendingOperationItem(s):n==="file_uploads"?this.saveFileUploadItem(s):n==="lookup_values"?this.saveLookupValueItem(s):n==="left_menu"?this.saveLeftMenuItem(s):n==="fields_config"?this.saveFieldsConfigItem(s):n==="list_view_records"?this.saveListViewRecordsItem(s):n==="aws_s3_list"?this.saveAwsS3ListItem(s):this.saveGenericItem(n,s)}catch(r){throw console.error(`\u274C Failed to save item to ${t}:`,r),r}}async saveMetadataItem(t){const s=`
            INSERT OR REPLACE INTO metadata_cache (
                id, object_api_name, encrypted_data, cached_at, user_cache_id,
                record_count, has_enhanced_schema, mobile_simple, mobile_complete,
                lookup_options, picklist_options, field_types, field_records,
                controlling_records, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `,r=[t.id,t.objectApiName||"",JSON.stringify(t.encryptedData||""),t.cachedAt||new Date().toISOString(),t.userCacheId||"",t.recordCount||0,t.hasEnhancedSchema?1:0,t.mobile_simple?1:0,t.mobile_complete?1:0,JSON.stringify(t.lookupOptions||{}),JSON.stringify(t.picklistOptions||{}),JSON.stringify(t.fieldTypes||{}),JSON.stringify(t.fieldRecords||[]),JSON.stringify(t.controllingRecords||[])];return await this.dbConnection.run(s,r),console.log(`\u{1F4E6} Saved metadata item: ${t.id}`),t}async saveSafetyEventItem(t){const s=`
            INSERT OR REPLACE INTO safety_events (
                id, object_type, encrypted_data, sync_status, created_at,
                attempts, last_attempt, last_error, created_offline
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `,r=[t.id,t.objectType||"",JSON.stringify(t.encryptedData||""),t.syncStatus||"pending",t.createdAt||new Date().toISOString(),t.attempts||0,t.lastAttempt||null,t.lastError||null,1];return await this.dbConnection.run(s,r),console.log(`\u{1F4BE} Saved safety event: ${t.id}`),t}async savePendingOperationItem(t){const s=`
            INSERT OR REPLACE INTO pending_operations (
                operation_id, type, object_type, timestamp, data,
                attempts, last_attempt, status
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `,r=[t.id||t.operation_id,t.type,t.objectType||"",t.timestamp||Date.now(),JSON.stringify(t.data||{}),t.attempts||0,t.lastAttempt||null,t.status||"pending"],n=await this.dbConnection.run(s,r);return console.log(`\u{1F4CB} Saved pending operation: ${t.id||t.operation_id}`),{...t,dbId:n.changes?.lastId||null}}async saveFileUploadItem(t){console.log("\u{1F4C1} Saving file upload item:",JSON.stringify(t));const s=`
            INSERT OR REPLACE INTO file_uploads (
                id, form_type, record_id, form_temp_id, file_name,
                file_path, file_size, mime_type, upload_status,
                folder_path, s3_key, s3_url, retry_attempts, last_error, related_record_id, description, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `,r=[t.id,t.formType||"",t.recordId||"",t.formTempId||"",t.fileName||"",t.filePath||"",t.fileSize||0,t.mimeType||"",t.uploadStatus||"pending",t.folderPath||"",t.s3Key||"",t.s3Url||"",t.retryAttempts||0,t.lastError||"",t.relatedRecordId||"",t.description||""];return await this.dbConnection.run(s,r),console.log(`\u{1F4C1} Saved file upload: ${t.id}`,{fileName:t.fileName,formType:t.formType,recordId:t.recordId,formTempId:t.formTempId,uploadStatus:t.uploadStatus,filePath:t.filePath}),t}async saveFileWithPath(t){console.log("\u{1F4C1} Saving file with enhanced path management:",JSON.stringify(t));const s={id:t.id||this.generateId(),formType:t.formType||"general",recordId:t.recordId||null,formTempId:t.formTempId||null,fileName:t.name||t.fileName,filePath:t.webPath||t.path||t.filePath,fileSize:t.size||0,mimeType:t.type||t.mimeType||"application/octet-stream",uploadStatus:"pending",folderPath:t.folderPath||(t.formType?`${t.formType}/${t.recordId||"temp"}`:"general"),s3Key:null,description:t.description||""};console.log("\u{1F4C1} Saving file with enhanced path management:",JSON.stringify(s));const r=await this.saveFileUploadItem(s);return console.log("\u{1F4C1} File saved successfully to SQLite:",r.id),r}async getPendingFileUploads(){const t=`
            SELECT * FROM file_uploads 
            WHERE upload_status = 'pending'
            ORDER BY created_at ASC
        `,s=await this.dbConnection.query(t);if(console.log(`\u{1F4C1} Found ${s.values?.length||0} pending file uploads`),s.values&&s.values.length>0)console.log("\u{1F4C1} Pending files details:",s.values.map(r=>({id:r.id,fileName:r.file_name,formType:r.form_type,recordId:r.record_id,formTempId:r.form_temp_id,uploadStatus:r.upload_status,filePath:r.file_path,description:r.description})));else{const r="SELECT COUNT(*) as total FROM file_uploads",n=await this.dbConnection.query(r);console.log("\u{1F4C1} Total files in database:",n.values?.[0]?.total||0);const i="SELECT upload_status, COUNT(*) as count FROM file_uploads GROUP BY upload_status",o=await this.dbConnection.query(i);console.log("\u{1F4C1} Files by status:",o.values)}return s.values||[]}async getFileUploadsByStatus(t){const s=`
            SELECT * FROM file_uploads 
            WHERE upload_status = ? 
            ORDER BY created_at DESC
        `;return(await this.dbConnection.query(s,[t])).values||[]}async getFileUploadsByRecord(t,s){const r=`
            SELECT * FROM file_uploads 
            WHERE form_type = ? AND record_id = ? AND upload_status != 'deleted'
            ORDER BY created_at DESC
        `;return(await this.dbConnection.query(r,[t,s])).values||[]}async updateFileUploadStatus(t,s,r=null,n=null,i=null,o=null){const a=`
            UPDATE file_uploads 
            SET upload_status = ?, s3_key = ?, s3_url = ?, 
                retry_attempts = COALESCE(?, retry_attempts),
                last_error = COALESCE(?, last_error),
                updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `,l=[s,r,n,i,o,t];return await this.dbConnection.run(a,l),console.log(`\u{1F4C1} Updated file upload status: ${t} -> ${s}`),this.getFileUploadById(t)}async getFileUploadById(t){const s="SELECT * FROM file_uploads WHERE id = ?";return(await this.dbConnection.query(s,[t])).values?.[0]||null}async updateFileRecordId(t,s,r){const n=`
            UPDATE file_uploads 
            SET record_id = ?, folder_path = ?, updated_at = CURRENT_TIMESTAMP
            WHERE form_type = ? AND form_temp_id = ?
        `,i=`${t}/${r}`,o=[r,i,t,s],a=await this.dbConnection.run(n,o);return console.log(`\u{1F4C1} Updated file record IDs for ${t}/${s} -> ${r}`),a}async cleanupOldFiles(t=30){const s=new Date;s.setDate(s.getDate()-t);const r=`
            DELETE FROM file_uploads 
            WHERE upload_status = 'uploaded' 
            AND updated_at < ?
        `,n=await this.dbConnection.run(r,[s.toISOString()]);return console.log(`\u{1F4C1} Cleaned up old uploaded files older than ${t} days`),n}async getFileUploadStats(){const t=`
            SELECT 
                upload_status,
                COUNT(*) as count,
                SUM(file_size) as total_size
            FROM file_uploads 
            GROUP BY upload_status
        `,s=await this.dbConnection.query(t),r={};return(s.values||[]).forEach(n=>{r[n.upload_status]={count:n.count,totalSize:n.total_size||0}}),r}generateId(){return"file_"+Date.now()+"_"+Math.random().toString(36).substr(2,9)}async getAllFileUploads(){const t="SELECT * FROM file_uploads ORDER BY created_at DESC";return(await this.dbConnection.query(t)).values||[]}async saveLookupValueItem(t){const s=`
            INSERT OR REPLACE INTO lookup_values (
                id, object_api_name, field_api_name, lookup_options,
                cached_at, user_cache_id
            ) VALUES (?, ?, ?, ?, ?, ?)
        `,r=[t.id,t.objectApiName||"",t.fieldApiName||"",JSON.stringify(t.lookupOptions||[]),t.cachedAt||new Date().toISOString(),t.userCacheId||""];return await this.dbConnection.run(s,r),console.log(`\u{1F517} Saved lookup values: ${t.id}`),t}async saveLeftMenuItem(t){const s=`
            INSERT OR REPLACE INTO left_menu (
                id, menu_items, cached_at, user_cache_id, updated_at
            ) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
        `,r=[t.id,JSON.stringify(t.menuItems||[]),t.cachedAt||new Date().toISOString(),t.userCacheId||""];return await this.dbConnection.run(s,r),console.log(`\u{1F4CB} Saved left menu item: ${t.id}`),t}async saveFieldsConfigItem(t){const s=`
            INSERT OR REPLACE INTO fields_config (
                id, object_api_name, field_configs, cached_at, user_cache_id, updated_at
            ) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `,r=[t.id,t.objectApiName||"",JSON.stringify(t.fieldConfigs||[]),t.cachedAt||new Date().toISOString(),t.userCacheId||""];return await this.dbConnection.run(s,r),console.log(`\u{1F4CB} Saved fields config: ${t.id} for ${t.objectApiName}`),t}async saveListViewRecordsItem(t){const s=`
            INSERT OR REPLACE INTO list_view_records (
                id, object_api_name, records, cached_at, user_cache_id, updated_at
            ) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `,r=[t.id,t.objectApiName||"",JSON.stringify(t.records||[]),t.cachedAt||new Date().toISOString(),t.userCacheId||""];return await this.dbConnection.run(s,r),console.log(`\u{1F4CB} Saved list view records: ${t.id} for ${t.objectApiName}`),t}async saveAwsS3ListItem(t){const s=`
            INSERT OR REPLACE INTO aws_s3_list (
                id, object_api_name, records, cached_at, user_cache_id, updated_at
            ) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `,r=[t.id,t.objectApiName||"",JSON.stringify(t.records||[]),t.cachedAt||new Date().toISOString(),t.userCacheId||""];return await this.dbConnection.run(s,r),console.log(`\u{1F4CB} Saved AWS S3 list: ${t.id} for ${t.objectApiName}`),t}async saveGenericItem(t,s){const r=`
            INSERT OR REPLACE INTO ${t} (
                id, name, data, sync_status
            ) VALUES (?, ?, ?, ?)
        `,n=[s.id,s.name||s.title||s.description||"",JSON.stringify(s),s.syncStatus||"pending"];return await this.dbConnection.run(r,n),console.log(`\u{1F4BE} Saved generic item to ${t}: ${s.id}`),s}async getAllItems(t){try{await this.init();const r=this.getTableMapping()[t]||t.toLowerCase(),n=`SELECT * FROM ${r} ORDER BY created_at DESC`,i=await this.dbConnection.query(n);return i.values?i.values.map(o=>this.transformRowToObject(r,o)):[]}catch(s){return console.error(`\u274C Failed to get all items from ${t}:`,s),[]}}async getById(t,s){try{await this.init();const n=this.getTableMapping()[t]||t.toLowerCase(),i=`SELECT * FROM ${n} WHERE id = ?`,o=await this.dbConnection.query(i,[s]);if(!o.values||o.values.length===0)throw new Error(`Item with id ${s} not found in ${t}`);return this.transformRowToObject(n,o.values[0])}catch(r){throw console.error(`\u274C Failed to get item ${s} from ${t}:`,r),r}}async deleteItem(t,s){try{await this.init();const i=`DELETE FROM ${this.getTableMapping()[t]||t.toLowerCase()} WHERE id = ?`;return await this.dbConnection.run(i,[s]),console.log(`\u{1F5D1}\uFE0F Deleted item ${s} from ${t}`),{success:!0,id:s}}catch(r){throw console.error(`\u274C Failed to delete item ${s} from ${t}:`,r),r}}async saveItems(t,s){try{await this.init();const r=[];for(const n of s){const i=await this.saveItem(t,n);r.push(i)}return console.log(`\u{1F4E6} Saved ${s.length} items to ${t}`),r}catch(r){throw console.error(`\u274C Failed to save items to ${t}:`,r),r}}async getPendingOperations(){try{await this.init();const t="SELECT * FROM pending_operations WHERE status = 'pending' ORDER BY timestamp ASC",s=await this.dbConnection.query(t);return s.values?s.values.map(r=>({id:r.operation_id,dbId:r.id,type:r.type,objectType:r.object_type,timestamp:r.timestamp,data:JSON.parse(r.data||"{}"),attempts:r.attempts||0,lastAttempt:r.last_attempt,status:r.status})):[]}catch(t){return console.error("\u274C Failed to get pending operations:",t),[]}}async deletePendingOperation(t){try{await this.init();const s="DELETE FROM pending_operations WHERE operation_id = ?";return await this.dbConnection.run(s,[t]),console.log(`\u{1F5D1}\uFE0F Deleted pending operation: ${t}`),{success:!0,id:t}}catch(s){throw console.error(`\u274C Failed to delete pending operation ${t}:`,s),s}}async addPendingOperation(t){const s={...t,timestamp:t.timestamp||Date.now(),status:"pending"};return this.savePendingOperationItem(s)}async clearPendingOperations(){try{await this.init();const t="DELETE FROM pending_operations";await this.dbConnection.run(t),console.log("\u{1F5D1}\uFE0F Cleared all pending operations")}catch(t){throw console.error("\u274C Failed to clear pending operations:",t),t}}transformRowToObject(t,s){try{if(t==="metadata_cache")return{id:s.id,objectApiName:s.object_api_name,encryptedData:JSON.parse(s.encrypted_data||'""'),cachedAt:s.cached_at,userCacheId:s.user_cache_id,recordCount:s.record_count,hasEnhancedSchema:s.has_enhanced_schema===1,mobile_simple:s.mobile_simple===1,mobile_complete:s.mobile_complete===1,lookupOptions:JSON.parse(s.lookup_options||"{}"),picklistOptions:JSON.parse(s.picklist_options||"{}"),fieldTypes:JSON.parse(s.field_types||"{}"),fieldRecords:JSON.parse(s.field_records||"[]"),controllingRecords:JSON.parse(s.controlling_records||"[]")};if(t==="safety_events")return{id:s.id,objectType:s.object_type,encryptedData:JSON.parse(s.encrypted_data||'""'),syncStatus:s.sync_status,createdAt:s.created_at,attempts:s.attempts,lastAttempt:s.last_attempt,lastError:s.last_error};if(t==="file_uploads")return{id:s.id,formType:s.form_type,recordId:s.record_id,formTempId:s.form_temp_id,fileName:s.file_name,filePath:s.file_path,fileSize:s.file_size,mimeType:s.mime_type,uploadStatus:s.upload_status,folderPath:s.folder_path,s3Key:s.s3_key,s3_url:s.s3_url,relatedRecordId:s.related_record_id,description:s.description};if(t==="lookup_values")return{id:s.id,objectApiName:s.object_api_name,fieldApiName:s.field_api_name,lookupOptions:JSON.parse(s.lookup_options||"[]"),cachedAt:s.cached_at,userCacheId:s.user_cache_id};if(t==="left_menu")return{id:s.id,menuItems:JSON.parse(s.menu_items||"[]"),cachedAt:s.cached_at,userCacheId:s.user_cache_id};if(t==="fields_config")return{id:s.id,objectApiName:s.object_api_name,fieldConfigs:JSON.parse(s.field_configs||"[]"),cachedAt:s.cached_at,userCacheId:s.user_cache_id};if(t==="list_view_records")return{id:s.id,objectApiName:s.object_api_name,records:JSON.parse(s.records||"[]"),cachedAt:s.cached_at,userCacheId:s.user_cache_id};if(t==="aws_s3_list")return{id:s.id,objectApiName:s.object_api_name,records:JSON.parse(s.records||"[]"),cachedAt:s.cached_at,userCacheId:s.user_cache_id};if(t==="tabs")return{id:s.id,objectApiName:s.objectApiName,label:s.label,sortOrder:s.sortOrder,component:s.component,parentId:s.parentId,propsJson:s.propsJson?JSON.parse(s.propsJson):null,isActive:s.isActive===1,iconName:s.iconName,keepAlive:s.keepAlive===1,prefetch:s.prefetch===1};if(t==="metadata_version")return{name:s.name,version:s.version,lastUpdated:s.last_updated};{const r=JSON.parse(s.data||"{}");return{id:s.id,name:s.name,syncStatus:s.sync_status,...r}}}catch(r){return console.error("\u274C Failed to transform row:",r),s}}getTableMapping(){return{METADATA_CACHE:"metadata_cache",accounts:"accounts",contacts:"contacts",LOOKUP_VALUES:"lookup_values",pendingOperations:"pending_operations",fileUploads:"file_uploads",safetyEvents:"safety_events",LEFT_MENU:"left_menu",FIELDS_CONFIG:"fields_config",LIST_VIEW_RECORDS:"list_view_records",AWS_S3_LIST:"aws_s3_list",tabs:"tabs",TABS:"tabs",metadata_version:"metadata_version",METADATA_VERSION:"metadata_version"}}async close(){try{this.dbConnection&&(await this.dbConnection.close(),this.dbConnection=null,this.isInitialized=!1,console.log("\u2705 SQLite database closed"))}catch(t){console.error("\u274C Failed to close SQLite database:",t)}}async getStats(){try{await this.init();const t=Object.keys(this.getTableMapping()),s={};for(const r of t)try{const i=`SELECT COUNT(*) as count FROM ${this.getTableMapping()[r]||r.toLowerCase()}`,o=await this.dbConnection.query(i);s[r]=o.values[0]?.count||0}catch(n){s[r]=0}return s}catch(t){return console.error("\u274C Failed to get database stats:",t),{}}}}const R=new yt,me=3;class mt{constructor(){this.isSyncing=!1,this.syncQueue=[],this.retryQueue=[]}initAutoSync(){console.log("\u{1F680} Initializing enhanced file upload auto-sync..."),typeof window!="undefined"&&window.addEventListener("online",()=>{console.log("\u{1F310} Device came online - triggering file sync"),this.syncPendingFiles().catch(t=>{console.error("\u274C Online sync error:",t)})}),console.log("\u2705 Enhanced file upload auto-sync initialized")}stopAutoSync(){console.log("\u{1F6D1} File upload auto-sync stopped")}async syncPendingFiles(){try{if(!(await U.getStatus())?.connected)return console.log("\u{1F4F4} Capacitor reports offline, aborting file upload sync"),{success:!1,reason:"offline"}}catch(t){if(!O())return console.log("\u{1F4F4} Offline (fallback), aborting file upload sync"),{success:!1,reason:"offline"}}if(!O())return console.log("\u{1F4F4} Offline, skipping file upload sync"),{success:!1,reason:"offline"};if(this.isSyncing)return console.log("\u{1F504} File sync already in progress, skipping"),{success:!1,reason:"already_syncing"};this.isSyncing=!0,console.log("\u{1F680} Starting enhanced file upload sync...");try{const t=await R.getPendingFileUploads();if(t.length===0)return console.log("\u2705 No pending file uploads found"),{success:!0,uploaded:0};console.log(`\u{1F4C1} Found ${t.length} pending file uploads`);let s=0,r=0;const n=[];for(const o of t)try{console.log(`\u{1F4E4} Processing file upload: ${o.file_name}`),console.log("fileRecord",JSON.stringify(o)),await R.updateFileUploadStatus(o.id,"uploading"),this.dispatchFileUploadEvent("fileUploadProgress",{fileId:o.id,fileName:o.file_name,status:"uploading"});const a={id:o.id,name:o.file_name,webPath:o.file_path,type:o.mime_type,size:o.file_size,formType:o.form_type,recordId:o.record_id,folderPath:o.folder_path,description:o.description},l=await this.uploadWithRetry(a);l.success?(await R.updateFileUploadStatus(o.id,"uploaded",l.s3Key,l.s3Url),await this.removePendingOperation(o.id),s++,console.log(`\u2705 Successfully uploaded: ${o.file_name} -> ${l.s3Key}`),this.dispatchFileUploadEvent("fileUploadSuccess",{fileId:o.id,fileName:o.file_name,s3Key:l.s3Key,s3Url:l.s3Url}),n.push({fileId:o.id,fileName:o.file_name,status:"success",s3Key:l.s3Key,s3Url:l.s3Url})):l.reason==="offline"?(await R.updateFileUploadStatus(o.id,"pending",null,null,null,"Deferred while offline"),console.log(`\u23F8\uFE0F Deferred upload while offline: ${o.file_name}`),n.push({fileId:o.id,fileName:o.file_name,status:"deferred",reason:"offline"})):(await R.updateFileUploadStatus(o.id,"failed",null,null,null,l.error),r++,console.error(`\u274C Failed to upload: ${o.file_name} - ${l.error}`),this.dispatchFileUploadEvent("fileUploadError",{fileId:o.id,fileName:o.file_name,error:l.error}),n.push({fileId:o.id,fileName:o.file_name,status:"failed",error:l.error}))}catch(a){console.error(`\u274C Error processing file ${o.file_name}:`,a),await R.updateFileUploadStatus(o.id,"failed",null,null,null,a.message),r++,this.dispatchFileUploadEvent("fileUploadError",{fileId:o.id,fileName:o.file_name,error:a.message}),n.push({fileId:o.id,fileName:o.file_name,status:"failed",error:a.message})}const i={success:!0,total:t.length,uploaded:s,failed:r,results:n};return console.log("\u{1F3AF} File sync completed:",i),this.dispatchFileUploadEvent("fileUploadSyncComplete",i),i}catch(t){return console.error("\u274C Fatal error during file sync:",t),this.dispatchFileUploadEvent("fileUploadSyncError",{error:t.message}),{success:!1,error:t.message}}finally{this.isSyncing=!1}}async uploadWithRetry(t,s=1){try{console.log(`\u{1F4E4} Upload attempt ${s} for: ${t.webPath}`),console.log("fileRecord in line 294",JSON.stringify(t));const r=await et(t);if(r.success)return console.log(`\u2705 Successfully uploaded: ${t.name}`),console.log(`\u{1F517} S3 URL: ${r.s3Url}`),{success:!0,s3Key:r.s3Key,s3Url:r.s3Url};if(r.reason==="offline")return{success:!1,reason:"offline"};throw new Error(r.error||"Unknown upload error")}catch(r){return console.warn(`\u26A0\uFE0F Upload attempt ${s} failed for ${t.name}:`,r.message),s<me&&O()?(console.log(`\u23F3 Retrying upload for ${t.name} (attempt ${s+1})`),this.uploadWithRetry(t,s+1)):O()?(console.error(`\u274C Max retry attempts reached for: ${t.name}`),{success:!1,error:`Upload failed after ${me} attempts: ${r.message}`}):{success:!1,reason:"offline"}}}async removePendingOperation(t){try{const r=(await wt()).find(n=>n.id===t&&n.type==="UPLOAD_FILE");r&&(await Et(r.id),console.log(`\u{1F4DD} Removed pending operation for file: ${t}`))}catch(s){console.warn(`\u26A0\uFE0F Failed to remove pending operation for ${t}:`,s)}}async getPendingFileUploads(){try{return(await R.getPendingFileUploads()).map(s=>({id:s.id,fileName:s.file_name,fileSize:s.file_size,fileType:s.mime_type,formType:s.form_type,uploadStatus:s.upload_status,recordId:s.record_id,s3Key:s.s3_key,createdDate:s.created_at,updatedDate:s.updated_at}))}catch(t){return console.error("\u274C Error getting pending file uploads:",t),[]}}async getUploadStats(){try{return await R.getFileUploadStats()}catch(t){return console.error("\u274C Error getting upload stats:",t),{}}}async triggerManualSync(){return console.log("\u{1F504} Manual file upload sync triggered"),this.syncPendingFiles()}async syncFilesForRecord(t){if(!t)return console.error("\u274C Cannot sync files: No record ID provided"),{success:!1,error:"No record ID provided"};console.log(`\u{1F504} Syncing files for record ID: ${t}`);try{const s=await R.getPendingFileUploads();if(s.length===0)return console.log("\u2705 No pending file uploads found for sync"),{success:!0,uploaded:0};console.log(`\u{1F4C1} Found ${s.length} pending files to check for record ID`);let r=0;for(const n of s)if(!n.record_id||n.record_id===""){const i=n.form_type||"general",o={id:n.id,formType:i,recordId:t,fileName:n.file_name,filePath:n.file_path,fileSize:n.file_size,mimeType:n.mime_type,uploadStatus:n.upload_status,folderPath:`${i}/${t}`,s3Key:n.s3_key,s3Url:n.s3_url,retryAttempts:n.retry_attempts,lastError:n.last_error,description:n.description};await R.saveFileUploadItem(o),r++,console.log(`\u{1F4C1} Updated file ${n.id} with record ID: ${t}`)}return console.log(`\u{1F4C1} Updated ${r} files with record ID: ${t}`),r>0?this.syncPendingFiles():{success:!0,updated:r,uploaded:0}}catch(s){return console.error("\u274C Error syncing files for record:",s),{success:!1,error:s.message}}}isSyncInProgress(){return this.isSyncing}async cleanupOldFiles(t=30){try{console.log(`\u{1F9F9} Cleaning up uploaded files older than ${t} days`);const s=await R.cleanupOldFiles(t);return console.log("\u2705 Cleanup completed:",s),s}catch(s){return console.error("\u274C Error during cleanup:",s),null}}dispatchFileUploadEvent(t,s){try{const r=new CustomEvent(t,{detail:s,bubbles:!0,composed:!0});typeof window!="undefined"&&window.dispatchEvent&&window.dispatchEvent(r),console.log(`\u{1F4E1} Dispatched event: ${t}`,s)}catch(r){console.warn("\u26A0\uFE0F Failed to dispatch file upload event:",r)}}}const Z=new mt;typeof window!="undefined"&&(window.fileUploadSync=Z,Z.initAutoSync());async function wt(){try{console.log("\u{1F4F1} SQLite: Getting pending operations");const e=await R.getPendingOperations();return console.log(`\u{1F4F1} SQLite: Retrieved ${e.length} pending operations`),e}catch(e){return console.error("\u274C SQLite: Failed to get pending operations:",e),[]}}async function Et(e){try{console.log(`\u{1F4F1} SQLite: Deleting pending operation: ${e}`);const t=await R.deletePendingOperation(e);return console.log(`\u{1F4F1} SQLite: Deleted pending operation: ${e}`),t}catch(t){throw console.error(`\u274C SQLite: Failed to delete pending operation ${e}:`,t),t}}U.getStatus().then(e=>e.connected);async function O(){return(await U.getStatus()).connected}(async()=>{try{console.log("\u{1F680} Initializing SQLite service..."),await R.init(),console.log("\u2705 SQLite service initialized successfully")}catch(e){console.error("\u274C Failed to initialize SQLite service:",e)}})(),typeof window!="undefined"&&(window.fileUploadSync=Z,console.log("\u{1F4C1} File upload sync service made globally available from utils"));async function bt(e,t){try{try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(E){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}console.log("\u{1F680} Starting uploadFileToSalesforce with fileRecord:",JSON.stringify(e));const s=new FileReader,r=new Promise((E,S)=>{s.onloadend=()=>{const P=s.result.split(",")[1];E(P)},s.onerror=()=>S(new Error("Failed to read file as base64"))});s.readAsDataURL(t);const n=await r;console.log("\u{1F4C4} Converted file to base64, length:",n.length);const i=await z.getConnectionForComponent();let o=e.name,a=o.lastIndexOf("."),l=a!==-1?o.slice(0,a):o,h=a!==-1?o.slice(a):"";l=l.replace(/[^a-zA-Z0-9]+/g,"_"),l=l.replace(/^_+|_+$/g,"");const f=l+h,u=new Date().toISOString().replace(/[-:]/g,"").split(".")[0],d=`${e.recordId}_${u}_${f}`;console.log("\u{1F4C4} Creating ContentVersion record with filename:",d);const y=await ue();console.log("\u{1F4E4} Using JSForce to create ContentVersion"),console.log("Using direct base64 upload approach");const g={Title:d,PathOnClient:d,VersionData:n,FirstPublishLocationId:e.recordId,Description:e.description||"",NetworkId:y?.Id,ContentLocation:"S"};console.log("Creating ContentVersion with base64 data"),console.log("Base64 data length:",n.length);const w=await i.sobject("ContentVersion").create(g);if(!w.success)throw console.error("\u274C Failed to create ContentVersion:",w),new Error(`Failed to create ContentVersion: ${w.errors?.join(", ")}`);console.log("\u2705 ContentVersion created successfully with direct base64 upload, ID:",w.id);const c=w.id,b=(await i.query(`SELECT Id, ContentDocumentId FROM ContentVersion WHERE Id = '${c}'`)).records[0]?.ContentDocumentId;return console.log("\u2705 ContentDocument ID:",b),{success:!0,fileSize:t.size,fileName:d,contentVersionId:c,contentDocumentId:b,uploadType:"salesforce"}}catch(s){return console.error("\u274C uploadFileToSalesforce error:",s),{success:!1,error:s.message||s,uploadType:"salesforce"}}}async function _t(e){try{try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(c){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}const t=await he();if(console.log("\u{1F50D} S3 Configuration:",t),t&&t.Rhythm__customValue__c==="salesforce"?console.log("\u{1F4C1} Using Salesforce standard file upload method"):console.log("\u{1F4C1} Using S3 file upload method"),console.log("\u{1F680} Starting uploadFileToS3 with fileRecord:",e),!e||!e.webPath)throw new Error("\u274C No webPath in fileRecord");let s=e.name;const r=e.type||"image/jpeg";let n=s.lastIndexOf("."),i=n!==-1?s.slice(0,n):s,o=n!==-1?s.slice(n):"";i=i.replace(/[^a-zA-Z0-9]+/g,"_"),i=i.replace(/^_+|_+$/g,"");const a=i+o,l=new Date().toISOString().replace(/[-:]/g,"").split(".")[0];console.log("fileRecord in line 59",JSON.stringify(e));let h="";if(e.recordId&&e.formType)try{console.log("Getting customer and supplier info for folder path");const c=await de(e.formType,e.recordId);console.log("customerAndSupplierInfo",c),c&&c.supplierName&&c.supplierName.includes("_Personal_Files")&&(h=`${c.customerName}/${c.objectLabel}/${c.supplierName}`,console.log("folderName",h))}catch(c){console.error("Error getting customer and supplier info:",c)}const f=`${e.recordId}_${l}_${a}`;console.log("\u{1F50D} Getting presigned URL with fileName:",f),console.log("\u{1F4C2} FileRecord details:",{name:e.name,webPath:e.webPath,type:e.type,folderPath:h}),console.log("folderPath",h);try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(c){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}let u;if(!t||t.Rhythm__customValue__c!=="salesforce"){const c=await fetch("https://i3keec7y9j.execute-api.ap-south-1.amazonaws.com/default/preSignedUrl",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({filePath:`${h}/${f}`,type:"upload"})});if(console.log("\u{1F4E5} Presigned URL response status:",JSON.stringify(c)),!c.ok)throw new Error(`\u274C Failed to get presigned URL: ${c.status}`);const p=await c.json();if(console.log("\u{1F4DD} Raw Lambda response:",p),typeof p=="string")u=p,console.log("\u{1F517} Lambda returned URL directly as string");else if(p.url)u=p.url,console.log("\u{1F517} Lambda returned URL in object.url property");else if(p.uploadURL)u=p.uploadURL,console.log("\u{1F517} Lambda returned URL in object.uploadURL property");else throw console.error("\u274C Could not find URL in response:",p),new Error("\u274C No valid presigned URL found in Lambda response");console.log("\u{1F517} Using presigned URL:",u)}let d;if(e.webPath.startsWith("data:")){console.log("\u{1F4C4} Processing data URL...");const c=e.webPath.split(",");if(c.length===2){const p=c[1];console.log("\u{1F4C4} Extracted base64 from data URL, length:",p.length);const b=atob(p),E=new Uint8Array(b.length);for(let S=0;S<b.length;S++)E[S]=b.charCodeAt(S);d=new Blob([E],{type:r}),console.log("\u{1F4C4} Created blob from base64, size:",d.size,"bytes")}else throw new Error("\u274C Invalid data URL format")}else{console.log("\u{1F4C2} Processing file path..."),console.log("\u{1F4C2} Original webPath:",e.webPath);let c;e.webPath.startsWith("file://")?(c=e.webPath.replace("file://",""),console.log("\u{1F4C2} Extracted file:// path:",c)):e.webPath.startsWith("http")?(c=new URL(e.webPath).pathname.replace("/_capacitor_file_/",""),console.log("\u{1F4C2} Extracted webPath:",c)):(c=e.webPath,console.log("\u{1F4C2} Using direct path:",c)),console.log("\u{1F4D6} Reading file using Filesystem API...");const p=await ie.readFile({path:c}),b=p.data.includes(",")?p.data.split(",")[1]:p.data;console.log("\u{1F4C4} Base64 data length:",b.length),console.log("\u{1F4C4} Base64 starts with:",b.slice(0,20));const E=atob(b),S=new Uint8Array(E.length);for(let P=0;P<E.length;P++)S[P]=E.charCodeAt(P);d=new Blob([S],{type:r}),console.log("\u{1F4C4} Created blob from file data, size:",d.size,"bytes")}if(console.log("\u{1F4E6} Final blob details:"),console.log("\u{1F4E6} Blob size:",d.size,"bytes"),console.log("\u{1F4E6} Blob type:",d.type),d.size===0)throw new Error("\u{1F6AB} Blob size is zero \u2014 image data corrupted");try{const c=await d.arrayBuffer(),p=new Uint8Array(c);console.log("\u{1F50D} Blob content verification:"),console.log("\u{1F50D} First 10 bytes (should start with FFD8 for JPEG):",Array.from(p.slice(0,10))),console.log("\u{1F50D} Last 10 bytes:",Array.from(p.slice(-10))),p[0]===255&&p[1]===216?console.log("\u2705 Blob contains valid JPEG signature"):console.warn("\u26A0\uFE0F Blob does not contain JPEG signature, got:",p[0],p[1]);const b=URL.createObjectURL(d),E=new Image;E.onload=()=>{console.log("\u2705 Blob creates loadable image"),URL.revokeObjectURL(b)},E.onerror=()=>{console.error("\u274C Blob does not create loadable image"),URL.revokeObjectURL(b)},E.src=b}catch(c){console.error("\u274C Failed to test blob content:",c)}console.log("\u{1F4E6} Creating File object...");const y=new File([d],f,{type:r});console.log("\u{1F4E6} File object created:"),console.log("\u{1F4E6} File object size:",y.size,"bytes"),console.log("\u{1F4E6} File object type:",y.type),console.log("\u{1F4E6} File object name:",y.name);try{const c=await y.arrayBuffer(),p=new Uint8Array(c,0,Math.min(10,c.byteLength));console.log("\u{1F4E6} File object first 10 bytes:",Array.from(p))}catch(c){console.error("\u274C Could not test File object content:",c)}if(t&&t.Rhythm__customValue__c==="salesforce")return await bt(e,d);try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(c){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}const g=await fetch(u,{method:"PUT",body:y});if(console.log("\u{1F4E4} File object upload completed!"),console.log("\u{1F4E4} Response status:",g.status),console.log("\u{1F4E4} Response statusText:",g.statusText),console.log("\u{1F4E4} Response headers:",Object.fromEntries(g.headers.entries())),!g.ok){const c=await g.text();throw console.error("\u274C File object upload failed response body:",c),new Error(`\u274C File object upload failed with status ${g.status}: ${c}`)}const w=u.split("?")[0];return console.log("\u2705 SUCCESS! File object uploaded to S3"),console.log("\u2705 S3 URL:",w),console.log("\u2705 File size uploaded:",y.size,"bytes"),console.log(`\u{1F50D} Look for this exact file in AWS S3: ${h}/${f}`),{success:!0,fileSize:y.size,fileName:f,s3Url:w,s3Key:`${h}/${f}`}}catch(t){console.error("\u274C uploadFileToS3 error:",t);try{if(!(await U.getStatus())?.connected)return{success:!1,reason:"offline",error:"Device is offline (Capacitor Network)"}}catch(s){if(!O())return{success:!1,reason:"offline",error:"Device is offline"}}return{success:!1,error:t.message||t}}}export{_t as uploadFileToS3};
